function estimation. Furthermore, we include a summary of currently used algorithms for training
SV machines, covering both the quadratic (or convex) programming part and advanced methods for
dealing with large datasets. Finally, we mention some modications and extensions that have been
applied to the standard SV algorithm, and discuss the aspect of regularization from a SV perspective.

Keywords: machine learning, support vector machines, regression estimation

1. Introduction

The purpose of this paper is twofold. It should serve as a self-
contained introduction to Support Vector regression for readers
new to this rapidly developing eld of research.1 On the other
hand, it attempts to give an overview of recent developments in
the eld.

To this end, we decided to organize the essay as follows.
We start by giving a brief overview of the basic techniques in
Sections 1, 2 and 3, plus a short summary with a number of
gures and diagrams in Section 4. Section 5 reviews current
algorithmic techniques used for actually implementing SV
machines. This may be of most
interest for practitioners.
The following section covers more advanced topics such as
extensions of the basic SV algorithm, connections between SV
machines and regularization and briey mentions methods for
carrying out model selection. We conclude with a discussion
of open questions and problems and current directions of SV
research. Most of the results presented in this review paper
already have been published elsewhere, but the comprehensive
presentations and some details are new.

1.1. Historic background

The SV algorithm is a nonlinear generalization of the Gener-
alized Portrait algorithm developed in Russia in the sixties2

An extended version of this paper is available as NeuroCOLT Technical Report
TR-98-030.
0960-3174 C(cid:1) 2004 Kluwer Academic Publishers

(Vapnik and Lerner 1963, Vapnik and Chervonenkis 1964). As
such, it is rmly grounded in the framework of statistical learn-
ing theory, or VC theory, which has been developed over the last
three decades by Vapnik and Chervonenkis (1974) and Vapnik
(1982, 1995). In a nutshell, VC theory characterizes properties
of learning machines which enable them to generalize well to
unseen data.

In its present form, the SV machine was largely developed
at AT&T Bell Laboratories by Vapnik and co-workers (Boser,
Guyon and Vapnik 1992, Guyon, Boser and Vapnik 1993, Cortes
and Vapnik, 1995, Scholkopf, Burges and Vapnik 1995, 1996,
Vapnik, Golowich and Smola 1997). Due to this industrial con-
text, SV research has up to date had a sound orientation towards
real-world applications. Initial work focused on OCR (optical
character recognition). Within a short period of time, SV clas-
siers became competitive with the best available systems for
both OCR and object recognition tasks (Scholkopf, Burges and
Vapnik 1996, 1998a, Blanz et al. 1996, Scholkopf 1997). A
comprehensive tutorial on SV classiers has been published by
Burges (1998). But also in regression and time series predic-
tion applications, excellent performances were soon obtained
(Muller et al. 1997, Drucker et al. 1997, Stitson et al. 1999,
Mattera and Haykin 1999). A snapshot of the state of the art
in SV learning was recently taken at the annual Neural In-
formation Processing Systems conference (Scholkopf, Burges,
and Smola 1999a). SV learning has now evolved into an active
area of research. Moreover, it is in the process of entering the
standard methods toolbox of machine learning (Haykin 1998,
Cherkassky and Mulier 1998, Hearst et al. 1998). Scholkopf and

200

Smola and Scholkopf

Smola (2002) contains a more in-depth overview of SVM regres-
sion. Additionally, Cristianini and Shawe-Taylor (2000) and Her-
brich (2002) provide further details on kernels in the context of
classication.

1.2. The basic idea
Suppose we are given training data {(x1, y1), . . . , (x(cid:1), y(cid:1))} 
X  R, where X denotes the space of the input patterns (e.g.
X = Rd). These might be, for instance, exchange rates for some
currency measured at subsequent days together with correspond-
ing econometric indicators. In -SV regression (Vapnik 1995),
our goal is to nd a function f (x) that has at most  deviation
from the actually obtained targets yi for all the training data, and
at the same time is as at as possible. In other words, we do not
care about errors as long as they are less than , but will not
accept any deviation larger than this. This may be important if
you want to be sure not to lose more than  money when dealing
with exchange rates, for instance.

For pedagogical reasons, we begin by describing the case of

linear functions f , taking the form

f (x) = (cid:4)w, x(cid:5) + b with w  X , b  R

(1)
where (cid:4) , (cid:5) denotes the dot product in X . Flatness in the case
of (1) means that one seeks a small w. One way to ensure this is
to minimize the norm,3 i.e. (cid:7)w(cid:7)2 = (cid:4)w, w(cid:5). We can write this
problem as a convex optimization problem:

minimize

subject to

1
2

(cid:1)
(cid:7)w(cid:7)2
yi  (cid:4)w, xi(cid:5)  b  
(cid:4)w, xi(cid:5) + b  yi  

The tacit assumption in (2) was that such a function f actually
exists that approximates all pairs (xi , yi ) with  precision, or in
other words, that the convex optimization problem is feasible.
Sometimes, however, this may not be the case, or we also may
want to allow for some errors. Analogously to the soft mar-
gin loss function (Bennett and Mangasarian 1992) which was
used in SV machines by Cortes and Vapnik (1995), one can in-
troduce slack variables i , 
to cope with otherwise infeasible
constraints of the optimization problem (2). Hence we arrive at
the formulation stated in Vapnik (1995).

i

(cid:1)(cid:2)

minimize

subject to

1
2

i=1

(i + 
i )

(cid:7)w(cid:7)2 + C


 yi  (cid:4)w, xi(cid:5)  b   + i

(cid:4)w, xi(cid:5) + b  yi   + 
i , 

 0

i

i

The constant C > 0 determines the trade-off between the at-
ness of f and the amount up to which deviations larger than
 are tolerated. This corresponds to dealing with a so called
-insensitive loss function || described by
if ||  
otherwise.

0
||  

|| :=

(cid:1)

(4)

(2)

(3)

Fig. 1. The soft margin loss setting for a linear SVM (from Scholkopf
and Smola, 2002)

Figure 1 depicts the situation graphically. Only the points outside
the shaded region contribute to the cost insofar, as the deviations
are penalized in a linear fashion. It turns out that in most cases
the optimization problem (3) can be solved more easily in its dual
formulation.4 Moreover, as we will see in Section 2, the dual for-
mulation provides the key for extending SV machine to nonlinear
functions. Hence we will use a standard dualization method uti-
lizing Lagrange multipliers, as described in e.g. Fletcher (1989).

1.3. Dual problem and quadratic programs

The key idea is to construct a Lagrange function from the ob-
jective function (it will be called the primal objective function
in the rest of this article) and the corresponding constraints, by
introducing a dual set of variables. It can be shown that this
function has a saddle point with respect to the primal and dual
variables at the solution. For details see e.g. Mangasarian (1969),
McCormick (1983), and Vanderbei (1997) and the explanations
in Section 5.2. We proceed as follows:
(i + 

i )  (cid:1)(cid:2)

(i i + 

(cid:7)w(cid:7)2 + C

(cid:1)(cid:2)


i )

i

L := 1
2

i=1

i=1

 (cid:1)(cid:2)
 (cid:1)(cid:2)

i=1

i=1

i ( + i  yi + (cid:4)w, xi(cid:5) + b)

i ( + 


i

+ yi  (cid:4)w, xi(cid:5)  b)

(5)

Here L is the Lagrangian and i , 
i are Lagrange multi-
pliers. Hence the dual variables in (5) have to satisfy positivity
constraints, i.e.

, i , 

i

()

, ()

 0.
, we refer to i and 
i .

i

i

i

Note that by ()
It follows from the saddle point condition that the partial
derivatives of L with respect to the primal variables (w, b, i , 
i )
have to vanish for optimality.
(

 i ) = 0

(7)

(6)

b L = (cid:1)(cid:2)
w L = w  (cid:1)(cid:2)

i=1

i

i=1
L = C  ()

i

 ()


i

(i  
 ()

i )xi = 0
= 0

i

(8)

(9)

A tutorial on support vector regression

201

Substituting (7), (8), and (9) into (5) yields the dual optimization
problem.


 1

2

(cid:1)(cid:2)

(cid:1)(cid:2)
(cid:1)(cid:2)

i, j=1

i=1

(i  

i ) + (cid:1)(cid:2)

j )(cid:4)xi , x j(cid:5)
yi (i  
i )

(i  

i )( j  

(i + 
i ) = 0 and i , 

i=1

i

(10)

 [0, C]

maximize

subject to

i=1

In conjunction with an analogous analysis on 

max{ + yi  (cid:4)w, xi(cid:5)| i < C or 
min{ + yi  (cid:4)w, xi(cid:5)| i > 0 or 

(16)
 (0, C) the inequalities become equalities. See

If some ()
also Keerthi et al. (2001) for further means of choosing b.

i we have
> 0}  b 
< C}

i

i

i

Another way of computing b will be discussed in the context
of interior point optimization (cf. Section 5). There b turns out
to be a by-product of the optimization process. Further consid-
erations shall be deferred to the corresponding section. See also
Keerthi et al. (1999) for further methods to compute the constant
offset.
A nal note has to be made regarding the sparsity of the SV
expansion. From (12) it follows that only for | f (xi )  yi|  
the Lagrange multipliers may be nonzero, or in other words, for
all samples inside the tube (i.e. the shaded region in Fig. 1)
i vanish: for | f (xi )  yi| <  the second factor in
the i , 
(12) is nonzero, hence i , 
i has to be zero such that the KKT
conditions are satised. Therefore we have a sparse expansion
of w in terms of xi (i.e. we do not need all xi to describe w). The
examples that come with nonvanishing coefcients are called
Support Vectors.

2. Kernels

2.1. Nonlinearity by preprocessing

The next step is to make the SV algorithm nonlinear. This, for
instance, could be achieved by simply preprocessing the training
patterns xi by a map  : X  F into some feature space F,
as described in Aizerman, Braverman and Rozonoer (1964) and
Nilsson (1965) and then applying the standard SV regression
algorithm. Let us have a brief look at an example given in Vapnik
(1995).



Example 1 (Quadratic features in R2). Consider the map  :
R2  R3 with (x1, x2) = (x 2
2 ). It is understood
that the subscripts in this case refer to the components of x  R2.
Training a linear SV machine on the preprocessed features would
yield a quadratic function.

2x1x2, x 2

,

1

While this approach seems reasonable in the particular ex-
ample above, it can easily become computationally infeasible
for both polynomial features of higher order and higher di-
mensionality, as the number of different monomial features
), where d = dim(X ). Typical values
of degree p is (d+ p1
for OCR tasks (with good performance) (Scholkopf, Burges
and Vapnik 1995, Scholkopf et al. 1997, Vapnik 1995) are
p = 7, d = 28  28 = 784, corresponding to approximately
3.7  1016 features.

p

2.2. Implicit mapping via kernels

Clearly this approach is not feasible and we have to nd a com-
putationally cheaper way. The key observation (Boser, Guyon

In deriving (10) we already eliminated the dual variables i , 
= C 
through condition (9) which can be reformulated as ()
()

i

i

i

w = (cid:1)(cid:2)

. Equation (8) can be rewritten as follows
(i

i )xi , thus f (x)= (cid:1)(cid:2)

(i

i )(cid:4)xi , x(cid:5)+ b.

(11)

i=1

i=1

This is the so-called Support Vector expansion, i.e. w can be
completely described as a linear combination of the training
patterns xi . In a sense, the complexity of a functions represen-
tation by SVs is independent of the dimensionality of the input
space X , and depends only on the number of SVs.

Moreover, note that the complete algorithm can be described
in terms of dot products between the data. Even when evalu-
ating f (x) we need not compute w explicitly. These observa-
tions will come in handy for the formulation of a nonlinear
extension.

1.4. Computing b

So far we neglected the issue of computing b. The latter can be
done by exploiting the so called KarushKuhnTucker (KKT)
conditions (Karush 1939, Kuhn and Tucker 1951). These state
that at the point of the solution the product between dual variables
and constraints has to vanish.

i ( + i  yi + (cid:4)w, xi(cid:5) + b) = 0
i ( + 
+ yi  (cid:4)w, xi(cid:5)  b) = 0


i

and

(C  i )i = 0
(C  
= 0.

i )

i

(12)

(13)

i

This allows us to make several useful conclusions. Firstly only
= C lie outside the -
samples (xi , yi ) with corresponding ()
= 0, i.e. there can never be a set
insensitive tube. Secondly i 
of dual variables i , 
i which are both simultaneously nonzero.
This allows us to conclude that
  yi + (cid:4)w, xi(cid:5) + b  0
  yi + (cid:4)w, xi(cid:5) + b  0

if i < C (14)

i = 0

if i > 0

(15)

and

i

202

have(cid:7)(cid:8)

and Vapnik 1992) is that for the feature map of example 2.1 we



x 2
1

,

2x1x2, x 2
2



(cid:12)2
1

,

x

(cid:12)

(cid:12)

1x

2x

2, x

(cid:12)2
2

(cid:8)

(cid:9)

,

(cid:9)(cid:10) = (cid:4)x, x

(cid:12)(cid:5)2.

(17)

(cid:12)

(cid:12)

) := (cid:4)(x), (x

As noted in the previous section, the SV algorithm only depends
on dot products between patterns xi . Hence it sufces to know
)(cid:5) rather than  explicitly which allows
k(x, x
(cid:1)(cid:2)
us to restate the SV optimization problem:
(cid:1)(cid:2)

i )( j  

(i  

maximize

i ) + (cid:1)(cid:2)

j )k(xi , x j )
yi (i  
i )
 [0, C]

i=1
and i , 

i

(i + 
i ) = 0

(18)

subject to

Likewise the expansion of f (11) may be written as

Smola and Scholkopf

condition (Scholkopf, Burges and Smola 1999a). In the follow-
ing we will call such functions k admissible SV kernels.

Corollary 3 (Positive linear combinations of kernels). Denote
by k1, k2 admissible SV kernels and c1, c2  0 then
)

) := c1k1(x, x

) + c2k2(x, x

k(x, x

(22)

(cid:12)

(cid:12)

(cid:12)

is an admissible kernel. This follows directly from (21) by virtue
of the linearity of integrals.

More generally, one can show that the set of admissible ker-
nels forms a convex cone, closed in the topology of pointwise
convergence (Berg, Christensen and Ressel 1984).

Corollary 4 (Integrals of kernels). Let s(x, x
on X  X such that
k(x, x

(cid:12), z) dz

s(x, z)s(x

) :=

(cid:12)

(cid:11)

X

(cid:12)

) be a function

(23)

(i  

i )(xi )

and

exists. Then k is an admissible SV kernel.

i=1

i, j=1


 1

2

(cid:1)(cid:2)
(i  
w = (cid:1)(cid:2)
f (x) = (cid:1)(cid:2)

i=1

i=1

i=1

(i  

i )k(xi , x)+ b.

(19)

The difference to the linear case is that w is no longer given ex-
plicitly. Also note that in the nonlinear setting, the optimization
problem corresponds to nding the attest function in feature
space, not in input space.

2.3. Conditions for kernels

(cid:12)

(cid:11)

Tk f () :=

The question that arises now is, which functions k(x, x
) corre-
spond to a dot product in some feature space F. The following
theorem characterizes these functions (dened on X ).
Theorem 2 (Mercer 1909). Suppose k  L(X 2) such that
the integral operator Tk : L 2(X )  L 2(X ),
k(, x) f (x)d(x)

(20)
is positive (here  denotes a measure on X with (X ) nite
and supp() = X ). Let  j  L 2(X ) be the eigenfunction of Tk
(cid:14)= 0 and normalized such that
associated with the eigenvalue  j
(cid:7) j(cid:7)L2
= 1 and let  j denote its complex conjugate. Then
) =(cid:12)
1. ( j (T )) j  (cid:1)1.
(cid:12)
jN
2. k(x, x
(cid:12)

),
where the series converges absolutely and uniformly for al-
most all (x, x

) holds for almost all (x, x

 j  j (x) j (x

).

X

(cid:12)

(cid:12)

(cid:11)

XX

Less formally speaking this theorem means that if

(cid:12)

k(x, x

) f (x) f (x

(cid:12)

) dxdx

(cid:12)  0 for all f  L 2(X )

(21)

(cid:12)

holds we can write k(x, x
) as a dot product in some feature
space. From this condition we can conclude some simple rules
for compositions of kernels, which then also satisfy Mercers

This can be shown directly from (21) and (23) by rearranging the
order of integration. We now state a necessary and sufcient con-
) := k(x  x
(cid:12)
dition for translation invariant kernels, i.e. k(x, x
)
as derived in Smola, Scholkopf and Muller (1998c).

(cid:12)

Theorem 5 (Products of kernels). Denote by k1 and k2 admis-
sible SV kernels then

k(x, x

(cid:12)

) := k1(x, x

(cid:12)

(cid:12)

)k2(x, x

)

(24)

is an admissible kernel.

This can be seen by an application of the expansion part of
Mercers theorem to the kernels k1 and k2 and observing that
(cid:12)
) 2
)
each term in the double sum
gives rise to a positive coefcient when checking (21).

i (x) 1
 1

j (x) 2

i (x

j (x

1
i

2
j

i, j

(cid:12)

(cid:12)

Theorem 6 (Smola, Scholkopf and Muller 1998c). A transla-
) = k(x  x
(cid:11)
tion invariant kernel k(x, x
) is an admissible SV
kernels if and only if the Fourier transform
i(cid:4),x(cid:5)

F[k]() = (2)
 d

k(x)dx

(25)

e

(cid:12)

(cid:12)

2

X

is nonnegative.

We will give a proof and some additional explanations to this
theorem in Section 7. It follows from interpolation theory
(Micchelli 1986) and the theory of regularization networks
(Girosi, Jones and Poggio 1993). For kernels of the dot-product
(cid:12)(cid:5)), there exist sufcient conditions
type, i.e. k(x, x
for being admissible.

) = k((cid:4)x, x

(cid:12)

Theorem 7 (Burges 1999). Any kernel of dot-product type
k(x, x

) = k((cid:4)x, x
(cid:12)
k( )  0,  k( )  0

(cid:12)(cid:5)) has to satisfy
and

 k( ) +   2

 k( )  0 (26)

for any   0 in order to be an admissible SV kernel.

A tutorial on support vector regression

Note that the conditions in Theorem 7 are only necessary but
not sufcient. The rules stated above can be useful tools for
practitioners both for checking whether a kernel is an admissible
SV kernel and for actually constructing new kernels. The general
case is given by the following theorem.

203
B-splines of order 2n + 1, dened by the 2n + 1 convolution of
the unit inverval, are also admissible. We shall postpone further
considerations to Section 7 where the connection to regulariza-
tion operators will be pointed out in more detail.

(cid:12)

Theorem 8 (Schoenberg 1942). A kernel of dot-product type
(cid:12)(cid:5)) dened on an innite dimensional Hilbert
k(x, x
space, with a power series expansion

) = k((cid:4)x, x

(cid:2)

(27)

k(t) =

ant n
is admissible if and only if all an  0.

n=0

A slightly weaker condition applies for nite dimensional
spaces. For further details see Berg, Christensen and Ressel
(1984) and Smola, Ovari and Williamson (2001).

2.4. Examples

In Scholkopf, Smola and Muller (1998b) it has been shown, by
explicitly computing the mapping, that homogeneous polyno-
mial kernels k with p  N and

(cid:12)

k(x, x

) = (cid:4)x, x

(cid:12)(cid:5) p

(28)

(cid:12)

are suitable SV kernels (cf. Poggio 1975). From this observation
one can conclude immediately (Boser, Guyon and Vapnik 1992,
Vapnik 1995) that kernels of the type
) = ((cid:4)x, x

(29)
i.e. inhomogeneous polynomial kernels with p  N, c  0 are
admissible, too: rewrite k as a sum of homogeneous kernels and
apply Corollary 3. Another kernel, that might seem appealing
due to its resemblance to Neural Networks is the hyperbolic
tangent kernel

(cid:12)(cid:5) + c) p

k(x, x

(cid:12)

k(x, x

) = tanh( + (cid:4)x, x

(cid:12)(cid:5)).

(30)

By applying Theorem 8 one can check that this kernel does
not actually satisfy Mercers condition (Ovari 2000). Curiously,
the kernel has been successfully used in practice; cf. Scholkopf
(1997) for a discussion of the reasons.

Translation invariant kernels k(x, x

) are
quite widespread. It was shown in Aizerman, Braverman and
Rozonoer (1964), Micchelli (1986) and Boser, Guyon and Vap-
nik (1992) that

(cid:12)

) = k(x  x

(cid:12)

(cid:12)

) = e

(cid:12)(cid:7)2
 (cid:7)xx
2 2

k(x, x

(31)

is an admissible SV kernel. Moreover one can show (Smola
1996, Vapnik, Golowich and Smola 1997) that (1X denotes the
indicator function on the set X and  the convolution operation)

(cid:12)(cid:7)) with Bk := k(cid:13)

1[ 1

2

2 ]
, 1

(32)

i=1

k(x, x

(cid:12)

) = B2n+1((cid:7)x  x

3. Cost functions

So far the SV algorithm for regression may seem rather strange
and hardly related to other existing methods of function esti-
mation (e.g. Huber 1981, Stone 1985, Hardle 1990, Hastie and
Tibshirani 1990, Wahba 1990). However, once cast into a more
standard mathematical notation, we will observe the connec-
tions to previous work. For the sake of simplicity we will, again,
only consider the linear case, as extensions to the nonlinear one
are straightforward by using the kernel method described in the
previous chapter.

3.1. The risk functional

Let us for a moment go back to the case of Section 1.2. There, we
had some training data X := {(x1, y1), . . . , (x(cid:1), y(cid:1))}  X  R.
We will assume now, that this training set has been drawn iid
(independent and identically distributed) from some probabil-
ity distribution P(x, y). Our goal will be to nd a function f
minimizing the expected risk (cf. Vapnik 1982)

(cid:11)

R[ f ] =

c(x, y, f (x))d P(x, y)

(33)

(c(x, y, f (x)) denotes a cost function determining how we will
penalize estimation errors) based on the empirical data X. Given
that we do not know the distribution P(x, y) we can only use
X for estimating a function f
that minimizes R[ f ]. A possi-
ble approximation consists in replacing the integration by the
empirical estimate, to get the so called empirical risk functional

(cid:1)(cid:2)

Remp[ f ] := 1

(cid:1)

c(xi , yi , f (xi )).

(34)

i=1

A rst attempt would be to nd the empirical risk minimizer
f0 := argmin f H Remp[ f ] for some function class H. However,
if H is very rich, i.e. its capacity is very high, as for instance
when dealing with few data in very high-dimensional spaces,
this may not be a good idea, as it will lead to overtting and thus
bad generalization properties. Hence one should add a capacity
control term, in the SV case(cid:7)w(cid:7)2, which leads to the regularized
risk functional (Tikhonov and Arsenin 1977, Morozov 1984,
Vapnik 1982)

Rreg[ f ] := Remp[ f ] + 
2

(cid:7)w(cid:7)2

(35)

where  > 0 is a so called regularization constant. Many
algorithms like regularization networks (Girosi, Jones and
Poggio 1993) or neural networks with weight decay networks
(e.g. Bishop 1995) minimize an expression similar to (35).

204

3.2. Maximum likelihood and density models

The standard setting in the SV case is, as already mentioned in
Section 1.2, the -insensitive loss

c(x, y, f (x)) = |y  f (x)|.

(36)

It is straightforward to show that minimizing (35) with the par-
ticular loss function of (36) is equivalent to minimizing (3), the
only difference being that C = 1/((cid:1)).
Loss functions such like |y  f (x)| p

 with p > 1 may not
be desirable, as the superlinear increase leads to a loss of the
robustness properties of the estimator (Huber 1981): in those
cases the derivative of the cost function grows without bound.
For p < 1, on the other hand, c becomes nonconvex.
For the case of c(x, y, f (x)) = (y  f (x))2 we recover the
least mean squares t approach, which, unlike the standard SV
loss function, leads to a matrix inversion instead of a quadratic
programming problem.

The question is which cost function should be used in (35). On
the one hand we will want to avoid a very complicated function c
as this may lead to difcult optimization problems. On the other
hand one should use that particular cost function that suits the
problem best. Moreover, under the assumption that the samples
were generated by an underlying functional dependency plus
additive noise, i.e. yi = ftrue(xi )+ i with density p( ), then the
optimal cost function in a maximum likelihood sense is

c(x, y, f (x)) =  log p(y  f (x)).

(37)

(38)

This can be seen as follows. The likelihood of an estimate

X f := {(x1, f (x1)), . . . , (x(cid:1), f (x(cid:1)))}

for additive noise and iid data is

p(X f | X) = (cid:1)(cid:14)

p( f (xi )| (xi , yi )) = (cid:1)(cid:14)

i=1

(39)
Maximizing P(X f | X) is equivalent to minimizing  log P
(X f | X). By using (37) we get

i=1

p(yi  f (xi )).

 log P(X f | X) = (cid:1)(cid:2)

i=1

Smola and Scholkopf

However, the cost function resulting from this reasoning might
be nonconvex. In this case one would have to nd a convex
proxy in order to deal with the situation efciently (i.e. to nd
an efcient implementation of the corresponding optimization
problem).

If, on the other hand, we are given a specic cost function from
a real world problem, one should try to nd as close a proxy to
this cost function as possible, as it is the performance wrt. this
particular cost function that matters ultimately.

Table 1 contains an overview over some common density
models and the corresponding loss functions as dened by
(37).

The only requirement we will impose on c(x, y, f (x)) in the
following is that for xed x and y we have convexity in f (x).
This requirement is made, as we want to ensure the existence and
uniqueness (for strict convexity) of a minimum of optimization
problems (Fletcher 1989).

3.3. Solving the equations

For the sake of simplicity we will additionally assume c to
be symmetric and to have (at most) two (for symmetry) dis-
continuities at ,   0 in the rst derivative, and to be
zero in the interval [, ]. All loss functions from Table 1
take on the following
belong to this class. Hence c will
form.

c(x, y, f (x)) = c(|y  f (x)|)

(41)

Note the similarity to Vapniks -insensitive loss. It is rather
straightforward to extend this special choice to more general
convex cost functions. For nonzero cost functions in the inter-
val [, ] use an additional pair of slack variables. Moreover

we might choose different cost functions ci , c
i and different
values of i , 
i for each sample. At the expense of additional
Lagrange multipliers in the dual formulation additional discon-
tinuities also can be taken care of. Analogously to (3) we arrive at
a convex minimization problem (Smola and Scholkopf 1998a).
To simplify notation we will stick to the one of (3) and use C

c(xi , yi , f (xi )).

(40)

Table 1. Common loss functions and corresponding density models

-insensitive
Laplacian
Gaussian

Hubers robust loss

Polynomial

Piecewise polynomial

2

 2

Loss function
c( ) = ||
c( ) = ||
(cid:1)
c( ) = 1
c( ) =
(cid:1)
c( ) = 1
c( ) =

1

p

2

1
2 ( )2
||  
|| p
p p1 ( ) p
||   p1

p

if ||  
otherwise

if ||  
otherwise

Density model
p( ) = 1
2(1+) exp(||)
(cid:15)
(cid:16)
2 exp(||)
p( ) = 1

(cid:16)
(cid:15)
  2
p( ) = 1
2 exp
(cid:16)
(cid:15)
  2
 exp
p( ) 
 ||

(cid:16)
(cid:15)
exp
2(1/ p) exp(|| p)
p( ) = p
(cid:15)
  p
 exp
p( ) 
p p1
 ||
 p1


2

2

2

exp

p

if ||  
otherwise

(cid:16)

if ||  
otherwise

A tutorial on support vector regression

205

instead of normalizing by  and (cid:1).
(cid:7)w(cid:7)2 + C

minimize

(cid:1)(cid:2)

subject to

1
2

i=1

( c(i ) + c(
i ))


 yi  (cid:4)w, xi(cid:5)  b   + i

(cid:4)w, xi(cid:5) + b  yi   + 
i , 

 0

i

i

(42)

Again, by standard Lagrange multiplier techniques, exactly in
the same manner as in the|| case, one can compute the dual op-
timization problem (the main difference is that the slack variable
terms c( ()
) now have nonvanishing derivatives). We will omit
the indices i and
, where applicable to avoid tedious notation.
This yields



i

j )(cid:4)xi , x j(cid:5)

i )( j  
i )  (i + 
i )

i=1

 1
2

(i  

i=1
+C


(cid:1)(cid:2)
+ (cid:1)(cid:2)
i, j=1

yi (i  
(cid:1)(cid:2)
T (i ) + T (

i )
 w = (cid:1)(cid:2)

T ( ) := c( )    c( )
(cid:1)(cid:2)
(i  

i=1
  C c( )
 = inf{ | C c  }
,   0

(i  

i ) = 0

i )xi

i=1

maximize

where

subject to

(43)

Table 2. Terms of the convex optimization problem depending on the
choice of the loss function



 (cid:14)= 0
 = 0
 = 0
 = 0
 = 0
 = 0



  [0, C]
  [0, C]
  [0,)
  [0, C]
  [0,)
  [0, C]

-insensitive
Laplacian
Gaussian
Hubers

robust loss

Polynomial
Piecewise

polynomial

C T ()

0
0
 1
12
2 C
 1
12
 C
2
 p1
p C
 p1
 C

 1

p

p1 
 1

p
p1
p1 

p
p1

In the second case (   ) we have

p  1
p

T ( ) =   

  = 

(48)
and  = inf{ | C  } =  , which, in turn yields   [0, C].
Combining both cases we have

  [0, C] and T () =  p  1

 p

p1 

p

p1 .

 C

(49)

p  1
p

p

Table 2 contains a summary of the various conditions on  and
formulas for T () (strictly speaking T ( ())) for different cost
functions.5 Note that the maximum slope of c determines the
region of feasibility of , i.e. s := supR+  c( ) <  leads to
compact intervals [0, Cs] for . This means that the inuence
of a single pattern is bounded, leading to robust estimators
(Huber 1972). One can also observe experimentally that the
performance of a SV machine depends signicantly on the cost
function used (Muller et al. 1997, Smola, Scholkopf and Muller
1998b)
A cautionary remark is necessary regarding the use of cost
functions other than the -insensitive one. Unless  (cid:14)= 0 we
will lose the advantage of a sparse decomposition. This may
be acceptable in the case of few data, but will render the pre-
diction step extremely slow otherwise. Hence one will have to
trade off a potential loss in prediction accuracy with faster pre-
dictions. Note, however, that also a reduced set algorithm like
in Burges (1996), Burges and Scholkopf (1997) and Scholkopf
et al. (1999b) or sparse decomposition techniques (Smola and
Scholkopf 2000) could be applied to address this issue. In a
Bayesian setting, Tipping (2000) has recently shown how an L 2
cost function can be used without sacricing sparsity.

4. The bigger picture

Before delving into algorithmic details of the implementation
let us briey review the basic properties of the SV algorithm
for regression as described so far. Figure 2 contains a graphical
overview over the different steps in the regression stage.

The input pattern (for which a prediction is to be made) is
mapped into feature space by a map . Then dot products
are computed with the images of the training patterns under

3.4. Examples

Let us consider the examples of Table 1. We will show explicitly
for two examples how (43) can be further simplied to bring it
into a form that is practically useful. In the -insensitive case,
i.e. c( ) = || we get

T ( ) =     1 = 0.

Morover one can conclude from  c( ) = 1 that

 = inf{ | C  } = 0

and   [0, C].

(44)

(45)

For the case of piecewise polynomial loss we have to distinguish
two different cases:    and  >  . In the rst case we get

T ( ) = 1

p p1

 p  1
 p1

 p =  p  1

p

 1 p p

(46)

and  = inf{ | C 1 p p1  } =  C
 p

T ( ) =  p  1

 C

p

 1

p1 

1

p1 and thus

p1 

p

p1 .

(47)

206

Fig. 2. Architecture of a regression machine constructed by the SV
algorithm

the map . This corresponds to evaluating kernel functions
k(xi , x). Finally the dot products are added up using the weights
i = i  
i . This, plus the constant term b yields the nal
prediction output. The process described here is very similar to
regression in a neural network, with the difference, that in the
SV case the weights in the input layer are a subset of the training
patterns.

Figure 3 demonstrates how the SV algorithm chooses the
attest function among those approximating the original data
with a given precision. Although requiring atness only in
feature space, one can observe that the functions also are
very at in input space. This is due to the fact, that ker-
nels can be associated with atness properties via regular-

Smola and Scholkopf

ization operators. This will be explained in more detail in
Section 7.

Finally Fig. 4 shows the relation between approximation qual-
ity and sparsity of representation in the SV case. The lower the
precision required for approximating the original data, the fewer
SVs are needed to encode that. The non-SVs are redundant, i.e.
even without these patterns in the training set, the SV machine
would have constructed exactly the same function f . One might
think that this could be an efcient way of data compression,
namely by storing only the support patterns, from which the es-
timate can be reconstructed completely. However, this simple
analogy turns out to fail in the case of high-dimensional data,
and even more drastically in the presence of noise. In Vapnik,
Golowich and Smola (1997) one can see that even for moderate
approximation quality, the number of SVs can be considerably
high, yielding rates worse than the Nyquist rate (Nyquist 1928,
Shannon 1948).

5. Optimization algorithms

While there has been a large number of implementations of SV
algorithms in the past years, we focus on a few algorithms which
will be presented in greater detail. This selection is somewhat
biased, as it contains these algorithms the authors are most fa-
miliar with. However, we think that this overview contains some
of the most effective ones and will be useful for practitioners
who would like to actually code a SV machine by themselves.
But before doing so we will briey cover major optimization
packages and strategies.

Fig. 3. Left to right: approximation of the function sinc x with precisions  = 0.1, 0.2, and 0.5. The solid top and the bottom lines indicate the size
of the -tube, the dotted line in between is the regression

Fig. 4. Left to right: regression (solid line), datapoints (small dots) and SVs (big dots) for an approximation with  = 0.1, 0.2, and 0.5. Note the
decrease in the number of SVs

A tutorial on support vector regression

5.1. Implementations

Most commercially available packages for quadratic program-
ming can also be used to train SV machines. These are usually
numerically very stable general purpose codes, with special en-
hancements for large sparse systems. While the latter is a feature
that is not needed at all in SV problems (there the dot product
matrix is dense and huge) they still can be used with good suc-
cess.6

OSL: This package was written by IBM-Corporation (1992). It
uses a two phase algorithm. The rst step consists of solving
a linear approximation of the QP problem by the simplex al-
gorithm (Dantzig 1962). Next a related very simple QP prob-
lem is dealt with. When successive approximations are close
enough together, the second subalgorithm, which permits a
quadratic objective and converges very rapidly from a good
starting value, is used. Recently an interior point algorithm
was added to the software suite.

CPLEX by CPLEX-Optimization-Inc. (1994) uses a primal-dual
logarithmic barrier algorithm (Megiddo 1989) instead with
predictor-corrector step (see e.g. Lustig, Marsten and Shanno
1992, Mehrotra and Sun 1992).

MINOS by the Stanford Optimization Laboratory (Murtagh and
Saunders 1983) uses a reduced gradient algorithm in con-
junction with a quasi-Newton algorithm. The constraints are
handled by an active set strategy. Feasibility is maintained
throughout the process. On the active constraint manifold, a
quasi-Newton approximation is used.

MATLAB: Until recently the matlab QP optimizer delivered only
agreeable, although below average performance on classi-
cation tasks and was not all too useful for regression tasks
(for problems much larger than 100 samples) due to the fact
that one is effectively dealing with an optimization prob-
lem of size 2(cid:1) where at least half of the eigenvalues of the
Hessian vanish. These problems seem to have been addressed
in version 5.3 / R11. Matlab now uses interior point codes.

LOQO by Vanderbei (1994) is another example of an interior
point code. Section 5.3 discusses the underlying strategies in
detail and shows how they can be adapted to SV algorithms.
Maximum margin perceptron by Kowalczyk (2000) is an algo-
rithm specically tailored to SVs. Unlike most other tech-
niques it works directly in primal space and thus does not
have to take the equality constraint on the Lagrange multipli-
ers into account explicitly.

Iterative free set methods The algorithm by Kaufman (Bunch,
Kaufman and Parlett 1976, Bunch and Kaufman 1977, 1980,
Drucker et al. 1997, Kaufman 1999), uses such a technique
starting with all variables on the boundary and adding them as
the Karush Kuhn Tucker conditions become more violated.
This approach has the advantage of not having to compute
the full dot product matrix from the beginning. Instead it is
evaluated on the y, yielding a performance improvement
in comparison to tackling the whole optimization problem
at once. However, also other algorithms can be modied by

207

subset selection techniques (see Section 5.5) to address this
problem.

5.2. Basic notions

Most algorithms rely on results from the duality theory in convex
optimization. Although we already happened to mention some
basic ideas in Section 1.2 we will, for the sake of convenience,
briey review without proof the core results. These are needed
in particular to derive an interior point algorithm. For details and
proofs (see e.g. Fletcher 1989).

Uniqueness: Every convex constrained optimization problem
has a unique minimum. If the problem is strictly convex then
the solution is unique. This means that SVs are not plagued
with the problem of local minima as Neural Networks are.7
Lagrange function: The Lagrange function is given by the pri-
mal objective function minus the sum of all products between
constraints and corresponding Lagrange multipliers (cf. e.g.
Fletcher 1989, Bertsekas 1995). Optimization can be seen
as minimzation of the Lagrangian wrt. the primal variables
and simultaneous maximization wrt. the Lagrange multipli-
ers, i.e. dual variables. It has a saddle point at the solution.
Usually the Lagrange function is only a theoretical device to
derive the dual objective function (cf. Section 1.2).

Dual objective function: It

is derived by minimizing the
Lagrange function with respect to the primal variables and
subsequent elimination of the latter. Hence it can be written
solely in terms of the dual variables.

Duality gap: For both feasible primal and dual variables the pri-
mal objective function (of a convex minimization problem)
is always greater or equal than the dual objective function.
Since SVMs have only linear constraints the constraint qual-
ications of the strong duality theorem (Bazaraa, Sherali and
Shetty 1993, Theorem 6.2.4) are satised and it follows that
gap vanishes at optimality. Thus the duality gap is a measure
how close (in terms of the objective function) the current set
of variables is to the solution.

KarushKuhnTucker (KKT) conditions: A set of primal and
dual variables that is both feasible and satises the KKT
conditions is the solution (i.e. constraint  dual variable = 0).
The sum of the violated KKT terms determines exactly the
size of the duality gap (that is, we simply compute the
constraint  Lagrangemultiplier part as done in (55)). This
allows us to compute the latter quite easily.
A simple intuition is that for violated constraints the dual
variable could be increased arbitrarily, thus rendering the
Lagrange function arbitrarily large. This, however, is in con-
tradition to the saddlepoint property.

5.3. Interior point algorithms

In a nutshell the idea of an interior point algorithm is to com-
pute the dual of the optimization problem (in our case the dual
dual of Rreg[ f ]) and solve both primal and dual simultaneously.
This is done by only gradually enforcing the KKT conditions

208

to iteratively nd a feasible solution and to use the duality
gap between primal and dual objective function to determine
the quality of the current set of variables. The special avour
of algorithm we will describe is primal-dual path-following
(Vanderbei 1994).

In order to avoid tedious notation we will consider the slightly
more general problem and specialize the result to the SVM later.
It is understood that unless stated otherwise, variables like 
denote vectors and i denotes its i-th component.

q() + (cid:4)c, (cid:5)

1
2

minimize
subject to A = b

and l    u

(50)
with c, , l, u  Rn, A  Rnm, b  Rm, the inequalities be-
tween vectors holding componentwise and q() being a convex
function of . Now we will add slack variables to get rid of all
inequalities but the positivity constraints. This yields:

minimize
subject to A = b,   g = l,  + t = u,

(51)

q() + (cid:4)c, (cid:5)

1
2
g, t  0,  free

The dual of (51) is

maximize

subject to

1
2
1
2

(q()  (cid:4)(cid:17)q(), )(cid:5) + (cid:4)b, y(cid:5) + (cid:4)l, z(cid:5)  (cid:4)u, s(cid:5)
(cid:17)q() + c  (Ay)
(cid:18) + s = z, s, z  0, y free

Moreover we get the KKT conditions, namely

gi zi = 0 and

si ti = 0 for all i  [1 . . . n].

(52)

(53)

A necessary and sufcient condition for the optimal solution is
that the primal/dual variables satisfy both the feasibility condi-
tions of (51) and (52) and the KKT conditions (53). We pro-
ceed to solve (51)(53) iteratively. The details can be found in
Appendix A.

5.4. Useful tricks

Before proceeding to further algorithms for quadratic optimiza-
tion let us briey mention some useful tricks that can be applied
to all algorithms described subsequently and may have signif-
icant impact despite their simplicity. They are in part derived
from ideas of the interior-point approach.

Training with different regularization parameters: For several
reasons (model selection, controlling the number of support
vectors, etc.) it may happen that one has to train a SV ma-
chine with different regularization parameters C, but other-
wise rather identical settings. If the parameters Cnew =  Cold
is not too different it is advantageous to use the rescaled val-
ues of the Lagrange multipliers (i.e. i , 
i ) as a starting point
for the new optimization problem. Rescaling is necessary to
satisfy the modied constraints. One gets

new =  old

and likewise bnew =  bold.

(54)

Smola and Scholkopf

Assuming that the (dominant) convex part q() of the pri-
mal objective is quadratic, the q scales with  2 where as the
linear part scales with  . However, since the linear term dom-
inates the objective function, the rescaled values are still a
better starting point than  = 0. In practice a speedup of
approximately 95% of the overall training time can be ob-
served when using the sequential minimization algorithm,
cf. (Smola 1998). A similar reasoning can be applied when
retraining with the same regularization parameter but differ-
ent (yet similar) width parameters of the kernel function. See
Cristianini, Campbell and Shawe-Taylor (1998) for details
thereon in a different context.

Monitoring convergence via the feasibility gap: In the case of
both primal and dual feasible variables the following con-
nection between primal and dual objective function holds:

Dual Obj. = Primal Obj. 

i

(cid:2)
(gi zi + si ti )
(cid:12)

i gi zi + si ti
 .

i

(55)

(56)

This can be seen immediately by the construction of the
Lagrange function. In Regression Estimation (with the -
insensitive loss function) one obtains for




(cid:2)

i

+ max(0, f (xi )  (yi + i ))(C  
i )
 min(0, f (xi )  (yi + i ))
+ max(0, (yi  
i )  f (xi ))(C  i )
 min(0, (yi  
i )  f (xi ))i

Thus convergence with respect to the point of the solution
can be expressed in terms of the duality gap. An effective

stopping rule is to require(cid:12)

i gi zi + si ti

|Primal Objective| + 1

 tol

(57)

for some precision tol. This condition is much in the spirit of
primal dual interior point path following algorithms, where
convergence is measured in terms of the number of signicant
gures (which would be the decimal logarithm of (57)), a
convention that will also be adopted in the subsequent parts
of this exposition.

5.5. Subset selection algorithms

The convex programming algorithms described so far can be
used directly on moderately sized (up to 3000) samples datasets
without any further modications. On large datasets, however, it
is difcult, due to memory and cpu limitations, to compute the
dot product matrix k(xi , x j ) and keep it in memory. A simple
calculation shows that for instance storing the dot product matrix
of the NIST OCR database (60.000 samples) at single precision
would consume 0.7 GBytes. A Cholesky decomposition thereof,
which would additionally require roughly the same amount of
memory and 64 Teraops (counting multiplies and adds sepa-
rately), seems unrealistic, at least at current processor speeds.

A rst solution, which was introduced in Vapnik (1982) relies
on the observation that the solution can be reconstructed from
the SVs alone. Hence, if we knew the SV set beforehand, and

A tutorial on support vector regression

it tted into memory, then we could directly solve the reduced
problem. The catch is that we do not know the SV set before
solving the problem. The solution is to start with an arbitrary
subset, a rst chunk that ts into memory, train the SV algorithm
on it, keep the SVs and ll the chunk up with data the current
estimator would make errors on (i.e. data lying outside the -
tube of the current regression). Then retrain the system and keep
on iterating until after training all KKT-conditions are satised.
The basic chunking algorithm just postponed the underlying
problem of dealing with large datasets whose dot-product matrix
cannot be kept in memory: it will occur for larger training set
sizes than originally, but it is not completely avoided. Hence
the solution is Osuna, Freund and Girosi (1997) to use only a
subset of the variables as a working set and optimize the problem
with respect to them while freezing the other variables. This
method is described in detail in Osuna, Freund and Girosi (1997),
Joachims (1999) and Saunders et al. (1998) for the case of pattern
recognition.8

An adaptation of these techniques to the case of regression
with convex cost functions can be found in Appendix B. The
basic structure of the method is described by Algorithm 1.

Algorithm 1.: Basic structure of a working set algorithm

= 0

Initialize i , 
Choose arbitrary working set Sw
repeat

i

Compute coupling terms (linear and constant) for Sw (see
Appendix A.3)
Solve reduced optimization problem
Choose new Sw from variables i , 
KKT conditions

i not satisfying the

until working set Sw = 

5.6. Sequential minimal optimization

Recently an algorithmSequential Minimal Optimization
(SMO)was proposed (Platt 1999) that puts chunking to the
extreme by iteratively selecting subsets only of size 2 and op-
timizing the target function with respect to them. It has been
reported to have good convergence properties and it is easily
implemented. The key point is that for a working set of 2 the
optimization subproblem can be solved analytically without ex-
plicitly invoking a quadratic optimizer.

While readily derived for pattern recognition by Platt (1999),
one simply has to mimick the original reasoning to obtain an
extension to Regression Estimation. This is what will be done
in Appendix C (the pseudocode can be found in Smola and
Scholkopf (1998b)). The modications consist of a pattern de-
pendent regularization, convergence control via the number of
signicant gures, and a modied system of equations to solve
the optimization problem in two variables for regression analyt-
ically.

Note that the reasoning only applies to SV regression with
the  insensitive loss functionfor most other convex cost func-

209

tions an explicit solution of the restricted quadratic programming
problem is impossible. Yet, one could derive an analogous non-
quadratic convex optimization problem for general cost func-
tions but at the expense of having to solve it numerically.

The exposition proceeds as follows: rst one has to derive
the (modied) boundary conditions for the constrained 2 indices
(i, j) subproblem in regression, next one can proceed to solve the
optimization problem analytically, and nally one has to check,
which part of the selection rules have to be modied to make
the approach work for regression. Since most of the content is
fairly technical it has been relegated to Appendix C.

The main difference in implementations of SMO for regres-
sion can be found in the way the constant offset b is determined
(Keerthi et al. 1999) and which criterion is used to select a new
set of variables. We present one such strategy in Appendix C.3.
However, since selection strategies are the focus of current re-
search we recommend that readers interested in implementing
the algorithm make sure they are aware of the most recent de-
velopments in this area.

Finally, we note that just as we presently describe a generaliza-
tion of SMO to regression estimation, other learning problems
can also benet from the underlying ideas. Recently, a SMO
algorithm for training novelty detection systems (i.e. one-class
classication) has been proposed (Scholkopf et al. 2001).

6. Variations on a theme

There exists a large number of algorithmic modications of the
SV algorithm, to make it suitable for specic settings (inverse
problems, semiparametric settings), different ways of measuring
capacity and reductions to linear programming (convex com-
binations) and different ways of controlling capacity. We will
mention some of the more popular ones.

6.1. Convex combinations and (cid:1)1-norms

All the algorithms presented so far involved convex, and at
best, quadratic programming. Yet one might think of reducing
the problem to a case where linear programming techniques
can be applied. This can be done in a straightforward fashion
(Mangasarian 1965, 1968, Weston et al. 1999, Smola, Scholkopf
and Ratsch 1999) for both SV pattern recognition and regression.
The key is to replace (35) by

Rreg[ f ] := Remp[ f ] + (cid:7)(cid:7)1

(58)
where (cid:7)(cid:7)1 denotes the (cid:1)1 norm in coefcient space. Hence one
uses the SV kernel expansion (11)

with a different way of controlling capacity by minimizing

Rreg[ f ] = 1

(cid:1)

i=1

c(xi , yi , f (xi )) + 

|i|.

(59)

i k(xi , x) + b

f (x) = (cid:1)(cid:2)
(cid:1)(cid:2)

i=1

(cid:1)(cid:2)

i=1

210

Smola and Scholkopf

i , 

i

, i , 

i

 0

maximize

For the -insensitive loss function this leads to a linear program-
ming problem. In the other cases, however, the problem still stays
a quadratic or general convex one, and therefore may not yield
the desired computational advantage. Therefore we will limit
ourselves to the derivation of the linear programming problem
in the case of |  | cost function. Reformulating (59) yields

minimize

subject to

i=1

(i + 

(cid:1)(cid:2)

yi  (cid:1)(cid:2)
(cid:1)(cid:2)


j=1

j=1
( j  

(cid:1)(cid:2)

i ) + C

(i + 
i )

i=1
( j  
j )k(x j , xi )  b   + i
j )k(x j , xi ) + b  yi   + 

i

Unlike in the classical SV case, the transformation into its dual
does not give any improvement in the structure of the optimiza-
tion problem. Hence it is best to minimize Rreg[ f ] directly, which
can be achieved by a linear optimizer, (e.g. Dantzig 1962, Lustig,
Marsten and Shanno 1990, Vanderbei 1997).

In (Weston et al. 1999) a similar variant of the linear SV ap-
proach is used to estimate densities on a line. One can show
(Smola et al. 2000) that one may obtain bounds on the gener-
alization error which exhibit even better rates (in terms of the
entropy numbers) than the classical SV case (Williamson, Smola
and Scholkopf 1998).

6.2. Automatic tuning of the insensitivity tube

Besides standard model selection issues, i.e. how to specify the
trade-off between empirical error and model capacity there also
exists the problem of an optimal choice of a cost function. In
particular, for the -insensitive cost function we still have the
problem of choosing an adequate parameter  in order to achieve
good performance with the SV machine.

Smola et al. (1998a) show the existence of a linear depen-
dency between the noise level and the optimal -parameter for
SV regression. However, this would require that we know some-
thing about the noise model. This knowledge is not available in
general. Therefore, albeit providing theoretical insight, this nd-
ing by itself is not particularly useful in practice. Moreover, if we
really knew the noise model, we most likely would not choose
the -insensitive cost function but the corresponding maximum
likelihood loss function instead.

There exists, however, a method to construct SV machines
that automatically adjust  and moreover also, at least asymptot-
ically, have a predetermined fraction of sampling points as SVs
(Scholkopf et al. 2000). We modify (35) such that  becomes a
variable of the optimization problem, including an extra term in
the primal objective function which attempts to minimize . In
other words

minimize R[ f ] := Remp[ f ] + 
2

(cid:7)w(cid:7)2 + 

(60)

(cid:23)

(cid:1)(cid:2)

i

(cid:7)w(cid:7)2 + C

1
2

i

i=1

 1
2

(cid:4)w, xi(cid:5) + b  yi   + 
i , 


 yi  (cid:4)w, xi(cid:5)  b   + i





 0
(cid:1)(cid:2)
+ (cid:1)(cid:2)
(cid:1)(cid:2)
(cid:1)(cid:2)
i=1
i , 

i ) = 0
i )  C(cid:1)
 [0, C]

i=1
(i  
(i + 

i, j=1
yi (i  
i )

(i  

i )( j  

i=1

i

j )k(xi , x j )

(62)

for some  > 0. Hence (42) becomes (again carrying out the
usual transformation between , (cid:1) and C)

( c(i ) + c(

i )) + (cid:1)

(cid:24)

(61)

minimize

subject to

We consider the standard || loss function. Computing the dual
of (62) yields

subject to

Note that the optimization problem is thus very similar to the -
SV one: the target function is even simpler (it is homogeneous),
but there is an additional constraint. For information on how this
affects the implementation (cf. Chang and Lin 2001).

Besides having the advantage of being able to automatically
determine  (63) also has another advantage. It can be used to
prespecify the number of SVs:

Theorem 9 (Scholkopf et al. 2000).

1.  is an upper bound on the fraction of errors.
2.  is a lower bound on the fraction of SVs.
3. Suppose the data has been generated iid from a distribution
p(x, y) = p(x) p(y | x) with a continuous conditional distri-
bution p(y | x). With probability 1, asymptotically,  equals
the fraction of SVs and the fraction of errors.

Essentially, -SV regression improves upon -SV regression by
allowing the tube width to adapt automatically to the data. What
is kept xed up to this point, however, is the shape of the tube.
One can, however, go one step further and use parametric tube
models with non-constant width, leading to almost identical op-
timization problems (Scholkopf et al. 2000).

Combining -SV regression with results on the asymptotical
optimal choice of  for a given noise model (Smola et al. 1998a)
leads to a guideline how to adjust  provided the class of noise
models (e.g. Gaussian or Laplacian) is known.

Remark 10 (Optimal choice of ). Denote by p a probability
density with unit variance, and by P a famliy of noise models
generated from p by P := { p| p = 1
 )}. Moreover assume

 p( y

A tutorial on support vector regression

211

by making problems seemingly easier yet reliable via a map into
some even higher dimensional space.

In this section we focus on the connections between SV
methods and previous techniques like Regularization Networks
(Girosi, Jones and Poggio 1993).9
In particular we will show
that SV machines are essentially Regularization Networks (RN)
with a clever choice of cost functions and that the kernels are
Greens function of the corresponding regularization operators.
For a full exposition of the subject the reader is referred to Smola,
Scholkopf and Muller (1998c).

7.1. Regularization networks

Let us briey review the basic concepts of RNs. As in (35)
we minimize a regularized risk functional. However, rather than
enforcing atness in feature space we try to optimize some
smoothness criterion for the function in input space. Thus we
get

Rreg[ f ] := Remp[ f ] + 
2

(cid:7)P f (cid:7)2.

(64)

Here P denotes a regularization operator in the sense of
Tikhonov and Arsenin (1977), i.e. P is a positive semidenite
operator mapping from the Hilbert space H of functions f under
consideration to a dot product space D such that the expression
(cid:4)P f  Pg(cid:5) is well dened for f, g  H. For instance by choos-
ing a suitable operator that penalizes large variations of f one
can reduce the wellknown overtting effect. Another possible
setting also might be an operator P mapping from L 2(Rn) into
some Reproducing Kernel Hilbert Space (RKHS) (Aronszajn,
1950, Kimeldorf and Wahba 1971, Saitoh 1988, Scholkopf 1997,
Girosi 1998).

Using an expansion of f in terms of some symmetric function
k(xi , x j ) (note here, that k need not fulll Mercers condition
and can be chosen arbitrarily since it is not used to dene a
regularization term),

f (x) = (cid:1)(cid:2)

i=1

i k(xi , x) + b,

(65)

and the -insensitive cost function, this leads to a quadratic pro-
gramming problem similar to the one for SVs. Using

(66)

being the solution of

Di j := (cid:4)(Pk)(xi , .)  (Pk)(x j , .)(cid:5)
1 K (  
), with , 
(cid:1)(cid:2)
(  )
1 K (  )
(cid:18)
1
2
(  )
(i + 
(cid:1)(cid:2)
i )
i=1
(i  
and i , 

KD
y  
i ) = 0

(cid:18)

i

(67)

 [0, C].

we get  = D

minimize

subject to

i=1

Fig. 5. Optimal  and  for various degrees of polynomial additive
noise

that the data were drawn iid from p(x, y) = p(x) p(y  f (x))
with p(y  f (x)) continuous. Then under the assumption of
uniform convergence, the asymptotically optimal value of  is

(cid:11) 

 = 1 

p(t) dt


 := argmin
(p( ) + p( ))

(cid:25)
1

2

(cid:11) 



(cid:26)

p(t) dt

(63)

where



For polynomial noise models, i.e. densities of type exp(|| p)
one may compute the corresponding (asymptotically) optimal
values of . They are given in Fig. 5. For further details see
(Scholkopf et al. 2000, Smola 1998); an experimental validation
has been given by Chalimourda, Scholkopf and Smola (2000).
We conclude this section by noting that -SV regression is
related to the idea of trimmed estimators. One can show that the
regression is not inuenced if we perturb points lying outside the
tube. Thus, the regression is essentially computed by discarding
a certain fraction of outliers, specied by , and computing the
regression estimate from the remaining points (Scholkopf et al.
2000).

7. Regularization

So far we were not concerned about the specic properties of
the map  into feature space and used it only as a convenient
trick to construct nonlinear regression functions. In some cases
the map was just given implicitly by the kernel, hence the map
itself and many of its properties have been neglected. A deeper
understanding of the kernel map would also be useful to choose
appropriate kernels for a specic task (e.g. by incorporating
prior knowledge (Scholkopf et al. 1998a)). Finally the feature
map seems to defy the curse of dimensionality (Bellman 1961)

212

Unfortunately, this setting of the problem does not preserve spar-
sity in terms of the coefcients, as a potentially sparse decom-
position in terms of i and 
1 K , which is not
in general diagonal.

i is spoiled by D

7.2. Greens functions

Comparing (10) with (67) leads to the question whether and un-
der which condition the two methods might be equivalent and
therefore also under which conditions regularization networks
might lead to sparse decompositions, i.e. only a few of the ex-
pansion coefcients i in f would differ from zero. A sufcient
condition is D = K and thus KD
1 K = K (if K does not have
1 K = K holds on the image of
full rank we only need that KD
K ):

k(xi , x j ) = (cid:4)(Pk)(xi , .)  (Pk)(x j , .)(cid:5)

(68)

Our goal now is to solve the following two problems:

1. Given a regularization operator P, nd a kernel k such that a
SV machine using k will not only enforce atness in feature
space, but also correspond to minimizing a regularized risk
functional with P as regularizer.

2. Given an SV kernel k, nd a regularization operator P such
that a SV machine using this kernel can be viewed as a Reg-
ularization Network using P.

These two problems can be solved by employing the concept
of Greens functions as described in Girosi, Jones and Poggio
(1993). These functions were introduced for the purpose of solv-
ing differential equations. In our context it is sufcient to know
that the Greens functions G xi (x) of P

P satisfy





PG xi )(x) = xi (x).

(P

(69)

Here, xi (x) is the -distribution (not to be confused with the Kro-
necker symbol i j ) which has the property that (cid:4) f  xi
(cid:5) = f (xi ).
The relationship between kernels and regularization operators is
formalized in the following proposition:



Proposition 1 (Smola, Scholkopf and Muller 1998b). Let P
be a regularization operator, and G be the Greens function of
P. Then G is a Mercer Kernel such that D = K . SV machines
P
using G minimize risk functional (64) with P as regularization
operator.

In the following we will exploit this relationship in both ways:
to compute Greens functions for a given regularization operator
P and to infer the regularizer, given a kernel k.

7.3. Translation invariant kernels

Let us now more specically consider regularization operators
P that may be written as multiplications in Fourier space

(cid:11)

(cid:4)P f  Pg(cid:5) =

1

f () g()

d

(70)

(2)n/2



P()

Smola and Scholkopf
with f () denoting the Fourier transform of f (x), and P() =
P() real valued, nonnegative and converging to 0 for || 
 and  := supp[P()]. Small values of P() correspond to
a strong attenuation of the corresponding frequencies. Hence
small values of P() for large  are desirable since high fre-
f correspond to rapid changes in f .
quency components of
P() describes the lter properties of P
P. Note that no atten-
uation takes place for P() = 0 as these frequencies have been
excluded from the integration domain.
one can show by exploiting P() = P() = P() that

For regularization operators dened in Fourier Space by (70)



(cid:11)

G(xi , x) =

1

(2)n/2

Rn

ei (xix) P() d

(71)

is a corresponding Greens function satisfying translational in-
variance, i.e.

G(xi , x j ) = G(xi  x j )

and

G() = P().

(72)

This provides us with an efcient tool for analyzing SV kernels
and the types of capacity control they exhibit. In fact the above
is a special case of Bochners theorem (Bochner 1959) stating
that the Fourier transform of a positive measure constitutes a
positive Hilbert Schmidt kernel.

(cid:11)

(cid:2)

 2m

Example 2 (Gaussian kernels). Following the exposition of
Yuille and Grzywacz (1988) as described in Girosi, Jones and
Poggio (1993), one can see that for

(cid:7)P f (cid:7)2 =

m

dx

m!2m ( O m f (x))2

(73)
with O 2m = m and O 2m+1 = m,  being the Laplacian
and  the Gradient operator, we get Gaussians kernels (31).
Moreover, we can provide an equivalent representation of P
in terms of its Fourier properties, i.e. P() = e
up to a
multiplicative constant.

  2(cid:7)(cid:7)2

2

Training an SV machine with Gaussian RBF kernels (Scholkopf
et al. 1997) corresponds to minimizing the specic cost func-
tion with a regularization operator of type (73). Recall that (73)
means that all derivatives of f are penalized (we have a pseudod-
ifferential operator) to obtain a very smooth estimate. This also
explains the good performance of SV machines in this case, as it
is by no means obvious that choosing a at function in some high
dimensional space will correspond to a simple function in low
dimensional space, as shown in Smola, Scholkopf and Muller
(1998c) for Dirichlet kernels.

The question that arises now is which kernel to choose. Let

us think about two extreme situations.

1. Suppose we already knew the shape of the power spectrum
Pow() of the function we would like to estimate. In this case
we choose k such that k matches the power spectrum (Smola
1998).

2. If we happen to know very little about the given data a gen-
eral smoothness assumption is a reasonable choice. Hence

A tutorial on support vector regression

we might want to choose a Gaussian kernel. If computing
time is important one might moreover consider kernels with
compact support, e.g. using the Bqspline kernels (cf. (32)).
This choice will cause many matrix elements ki j = k(xix j )
to vanish.

The usual scenario will be in between the two extreme cases and
we will have some limited prior knowledge available. For more
information on using prior knowledge for choosing kernels (see
Scholkopf et al. 1998a).

7.4. Capacity control

All the reasoning so far was based on the assumption that there
exist ways to determine model parameters like the regularization
constant  or length scales  of rbfkernels. The model selec-
tion issue itself would easily double the length of this review
and moreover it is an area of active and rapidly moving research.
Therefore we limit ourselves to a presentation of the basic con-
cepts and refer the interested reader to the original publications.
It is important to keep in mind that there exist several fun-
damentally different approaches such as Minimum Description
Length (cf. e.g. Rissanen 1978, Li and Vitanyi 1993) which is
based on the idea that the simplicity of an estimate, and therefore
also its plausibility is based on the information (number of bits)
needed to encode it such that it can be reconstructed.
Bayesian estimation, on the other hand, considers the pos-
terior probability of an estimate, given the observations X =
{(x1, y1), . . . (x(cid:1), y(cid:1))}, an observation noise model, and a prior
probability distribution p( f ) over the space of estimates
is given by Bayes Rule p( f | X) p(X) =
(parameters). It
p(X | f ) p( f ). Since p(X) does not depend on f , one can maxi-
mize p(X | f ) p( f ) to obtain the so-called MAP estimate.10 As
a rule of thumb, to translate regularized risk functionals into
Bayesian MAP estimation schemes, all one has to do is to con-
sider exp(Rreg[ f ]) = p( f | X). For a more detailed discussion
(see e.g. Kimeldorf and Wahba 1970, MacKay 1991, Neal 1996,
Rasmussen 1996, Williams 1998).

A simple yet powerful way of model selection is cross valida-
tion. This is based on the idea that the expectation of the error
on a subset of the training sample not used during training is
identical to the expected error itself. There exist several strate-
gies such as 10-fold crossvalidation, leave-one out error ((cid:1)-fold
crossvalidation), bootstrap and derived algorithms to estimate
the crossvalidation error itself (see e.g. Stone 1974, Wahba 1980,
Efron 1982, Efron and Tibshirani 1994, Wahba 1999, Jaakkola
and Haussler 1999) for further details.

Finally, one may also use uniform convergence bounds such
as the ones introduced by Vapnik and Chervonenkis (1971). The
basic idea is that one may bound with probability 1   (with
 > 0) the expected risk R[ f ] by Remp[ f ] + (F , ), where
 is a condence term depending on the class of functions F.
Several criteria for measuring the capacity ofF exist, such as the
VC-Dimension which, in pattern recognition problems, is given
by the maximum number of points that can be separated by the

213

function class in all possible ways, the Covering Number which
is the number of elements fromF that are needed to coverF with
accuracy of at least , Entropy Numbers which are the functional
inverse of Covering Numbers, and many more variants thereof
(see e.g. Vapnik 1982, 1998, Devroye, Gyor and Lugosi 1996,
Williamson, Smola and Scholkopf 1998, Shawe-Taylor et al.
1998).

8. Conclusion

Due to the already quite large body of work done in the eld of
SV research it is impossible to write a tutorial on SV regression
which includes all contributions to this eld. This also would
be quite out of the scope of a tutorial and rather be relegated to
textbooks on the matter (see Scholkopf and Smola (2002) for a
comprehensive overview, Scholkopf, Burges and Smola (1999a)
for a snapshot of the current state of the art, Vapnik (1998) for an
overview on statistical learning theory, or Cristianini and Shawe-
Taylor (2000) for an introductory textbook). Still the authors
hope that this work provides a not overly biased view of the state
of the art in SV regression research. We deliberately omitted
(among others) the following topics.

8.1. Missing topics

Mathematical programming: Starting from a completely differ-
ent perspective algorithms have been developed that are sim-
ilar in their ideas to SV machines. A good primer might
be (Bradley, Fayyad and Mangasarian 1998). (Also see
Mangasarian 1965, 1969, Street and Mangasarian 1995). A
comprehensive discussion of connections between mathe-
matical programming and SV machines has been given by
(Bennett 1999).

Density estimation: with SV machines (Weston et al. 1999,
Vapnik 1999). There one makes use of the fact that the cu-
mulative distribution function is monotonically increasing,
and that its values can be predicted with variable condence
which is adjusted by selecting different values of  in the loss
function.

Dictionaries: were originally introduced in the context of
wavelets by (Chen, Donoho and Saunders 1999) to allow
for a large class of basis functions to be considered simulta-
neously, e.g. kernels with different widths. In the standard SV
case this is hardly possible except by dening new kernels as
linear combinations of differently scaled ones: choosing the
regularization operator already determines the kernel com-
pletely (Kimeldorf and Wahba 1971, Cox and OSullivan
1990, Scholkopf et al. 2000). Hence one has to resort to lin-
ear programming (Weston et al. 1999).

Applications: The focus of this review was on methods and
theory rather than on applications. This was done to limit
the size of the exposition. State of the art, or even record
performance was reported in Muller et al. (1997), Drucker
et al. (1997), Stitson et al. (1999) and Mattera and Haykin
(1999).

214

In many cases, it may be possible to achieve similar per-
formance with neural network methods, however, only if
many parameters are optimally tuned by hand, thus depend-
ing largely on the skill of the experimenter. Certainly, SV
machines are not a silver bullet. However, as they have
only few critical parameters (e.g. regularization and kernel
width), state-of-the-art results can be achieved with relatively
little effort.

8.2. Open issues

Being a very active eld there exist still a number of open is-
sues that have to be addressed by future research. After that
the algorithmic development seems to have found a more sta-
ble stage, one of the most important ones seems to be to nd
tight error bounds derived from the specic properties of ker-
nel functions. It will be of interest in this context, whether
SV machines, or similar approaches stemming from a lin-
ear programming regularizer, will lead to more satisfactory
results.

Moreover some sort of luckiness framework (Shawe-Taylor
et al. 1998) for multiple model selection parameters, similar to
multiple hyperparameters and automatic relevance detection in
Bayesian statistics (MacKay 1991, Bishop 1995), will have to
be devised to make SV machines less dependent on the skill of
the experimenter.

It is also worth while to exploit the bridge between regulariza-
tion operators, Gaussian processes and priors (see e.g. (Williams
1998)) to state Bayesian risk bounds for SV machines in order
to compare the predictions with the ones from VC theory. Op-
timization techniques developed in the context of SV machines
also could be used to deal with large datasets in the Gaussian
process settings.

Prior knowledge appears to be another important question in
SV regression. Whilst invariances could be included in pattern
recognition in a principled way via the virtual SV mechanism
and restriction of the feature space (Burges and Scholkopf 1997,
Scholkopf et al. 1998a), it is still not clear how (probably) more
subtle properties, as required for regression, could be dealt with
efciently.

Reduced set methods also should be considered for speeding
up prediction (and possibly also training) phase for large datasets
(Burges and Scholkopf 1997, Osuna and Girosi 1999, Scholkopf
et al. 1999b, Smola and Scholkopf 2000). This topic is of great
importance as data mining applications require algorithms that
are able to deal with databases that are often at least one order of
magnitude larger (1 million samples) than the current practical
size for SV regression.

Many more aspects such as more data dependent generaliza-
tion bounds, efcient training algorithms, automatic kernel se-
lection procedures, and many techniques that already have made
their way into the standard neural networks toolkit, will have to
be considered in the future.

Readers who are tempted to embark upon a more detailed
exploration of these topics, and to contribute their own ideas to

Smola and Scholkopf

this exciting eld, may nd it useful to consult the web page
www.kernel-machines.org.

Appendix A: Solving the interior-point
equations

A.1. Path following

Rather than trying to satisfy (53) directly we will solve a modied
version thereof for some  > 0 substituted on the rhs in the rst
place and decrease  while iterating.

gi zi = ,

si ti =  for all i  [1 . . . n].

(74)

Still it is rather difcult to solve the nonlinear system of equa-
tions (51), (52), and (74) exactly. However we are not interested
in obtaining the exact solution to the approximation (74). In-
stead, we seek a somewhat more feasible solution for a given ,
then decrease  and repeat. This can be done by linearizing the
above system and solving the resulting equations by a predictor
corrector approach until the duality gap is small enough. The
advantage is that we will get approximately equal performance
as by trying to solve the quadratic system directly, provided that
the terms in 2 are small enough.

A( + ) = b
 +   g  g = l
 +  + t + t = u
c + 1
2
+ s + s = z + z
(gi + gi )(zi + zi ) = 
(si + si )(ti + ti ) = 

q() + 1
2

q()  (A(y + y))
 2

(cid:18)

Solving for the variables in  we get

A = b  A =: 
  g = l   + g =: 
 + t = u    t =: 
 2
q()

(cid:18) + z  s  1
2

(Ay)

(cid:18) + s  z + 1
2

= c  (Ay)
1zg + z = g
g
1st + s = t
t
1 denotes the vector (1/g1, . . . , 1/gn), and t analo-
where g
1s the vector generated
gously. Moreover denote g
by the componentwise product of the two vectors. Solving for

q() =: 
1gz =: z
1t s =: s

1  z  g
1  s  t

1z and t

and subsequently restricts the solution to a feasible set

(cid:25)

(cid:26)

x,

x = max
u
100
g = min(  l, u)
t = min(u  , u)
z = min



(cid:25)
(cid:25)

(cid:25)
(cid:25)

1
2
 1
2

q() + c  (Ay)

s = min



q()  c + (Ay)

(cid:18)

(cid:26)

(cid:18)

, u

+ u
(cid:26)
100
+ u
100

, u

215

(cid:26)

(79)

(cid:26)

(76)

() denotes the Heavyside function, i.e. (x) = 1 for x > 0
and (x) = 0 otherwise.

A tutorial on support vector regression

g, t, z, s we get

g = z
t = s

1g(z  z) z = g
1t(s  s) s = t

1z(  )
1s(   )

where

 :=   z
 :=   s

1gz
1t s

(75)

Now we can formulate the reduced KKTsystem (see (Vanderbei
1994) for the quadratic case):

(cid:27)H A

(cid:18)

(cid:28)(cid:27)

(cid:28)

(cid:27)



=

(cid:28)

  g

1z   t

1s 



A

where H := ( 1

2

y
0
q() + g

 2

A.2. Iteration strategies

1z + t

1s).

For the predictor-corrector method we proceed as follows. In
the predictor step solve the system of (75) and (76) with  = 0
and all -terms on the rhs set to 0, i.e. z = z, s = s. The
values in  are substituted back into the denitions for z and
s and (75) and (76) are solved again in the corrector step. As the
quadratic part in (76) is not affected by the predictorcorrector
steps, we only need to invert the quadratic matrix once. This is
done best by manually pivoting for the H part, as it is positive
denite.

Next the values in  obtained by such an iteration step are used
to update the corresponding values in , s, t, z, . . . . To ensure
that the variables meet the positivity constraints, the steplength
 is chosen such that the variables move at most 1   of their
initial distance to the boundaries of the positive orthant. Usually
(Vanderbei 1994) one sets  = 0.05.

Another heuristic is used for computing , the parameter de-
termining how much the KKT-conditions should be enforced.
Obviously it is our aim to reduce  as fast as possible, however
if we happen to choose it too small, the condition of the equa-
tions will worsen drastically. A setting that has proven to work
robustly is

(cid:25)

(cid:26)2

 = (cid:4)g, z(cid:5) + (cid:4)s, t(cid:5)

2n

  1
 + 10

.

(77)

The rationale behind (77) is to use the average of the satisfac-
tion of the KKT conditions (74) as point of reference and then
decrease  rapidly if we are far enough away from the bound-
aries of the positive orthant, to which all variables (except y) are
constrained to.

Finally one has to come up with good initial values. Analo-
gously to Vanderbei (1994) we choose a regularized version of
(76) in order to determine the initial conditions. One solves

(cid:29)

(cid:8)

(cid:9)

1
2

 2

q() + 1
A

(cid:18)

A
1

(cid:30)(cid:27)

(cid:28)

=



y

(cid:27)

(cid:28)

c
b

A.3. Special considerations for SV regression

The algorithm described so far can be applied to both SV pattern
recognition and regression estimation. For the standard setting
in pattern recognition we have

i  j yi y j k(xi , x j )

(80)

and consequently i q() = 0,  2
the Hessian is dense and the only thing we can do is compute
its Cholesky factorization to compute (76). In the case of SV re-
gression, however we have (with  := (1, . . . , (cid:1), 
, . . . , 
(cid:1) ))

i  j q() = yi y j k(xi , x j ), i.e.

1

q() = (cid:1)(cid:2)

i, j=0

q() = (cid:1)(cid:2)

i )( j  

j )k(xi , x j )

(i  
(cid:1)(cid:2)

i, j=1
+ 2C

i=1

T (i ) + T (
i )

and therefore

T (i )

i q() = d
di
i  j q() = k(xi , x j ) + i j

 2

(81)

T (i )

(82)

d2
d2
i

j

j

i

i

(cid:12)

 j



K

(cid:12) ] where D, D

 2
i 
q(),  2


q() = k(xi , x j )
and  2
q() analogously. Hence we are dealing with

a matrix of type M := [ K+D K
K+D
are diagonal
matrices. By applying an orthogonal transformation M can be
inverted essentially by inverting an (cid:1)  (cid:1) matrix instead of a
2(cid:1)  2(cid:1) system. This is exactly the additional advantage one
can gain from implementing the optimization algorithm directly
instead of using a general purpose optimizer. One can show that
for practical implementations (Smola, Scholkopf and Muller
1998b) one can solve optimization problems using nearly ar-
bitrary convex cost functions as efciently as the special case of
-insensitive loss functions.

(78)

Finally note that due to the fact that we are solving the pri-
mal and dual optimization problem simultaneously we are also

216

computing parameters corresponding to the initial SV optimiza-
tion problem. This observation is useful as it allows us to obtain
the constant term b directly, namely by setting b = y. (see Smola
(1998) for details).

at sample xi , i.e.

i := yi  f (xi ) = yi 

Smola and Scholkopf

(cid:30)

.

(84)

k(xi , x j )(i  

i ) + b

(cid:29)

m(cid:2)

j=1

Appendix B: Solving the subset selection
problem

B.1. Subset optimization problem






We will adapt the exposition of Joachims (1999) to the case of
regression with convex cost functions. Without loss of general-
ity we will assume  (cid:14)= 0 and   [0, C] (the other situations
can be treated as a special case). First we will extract a reduced
optimization problem for the working set when all other vari-
ables are kept xed. Denote Sw  {1, . . . , (cid:1)} the working set
and S f := {1, . . . , (cid:1)}\Sw the xed set. Writing (43) as an opti-
mization problem only in terms of Sw yields
j )(cid:4)xi , x j(cid:5)
i )( j  
(cid:23)
(cid:2)
( j  

(i  

maximize

(cid:24)

(cid:2)
(cid:2)
(cid:2)

jS f

yi 
(i  
j )(cid:4)xi , x j(cid:5)
i )
i ) + C(T (i ) + T (
((i + 
(cid:2)
i )))
i ) = 
(i  
i )

iSw

 1
2
i, jSw
+
+
(cid:2)
iSw
(i  
iSw
i  [0, C]
with the xed set (cid:12)
the equality constraint by (cid:12)
iSw (i  
i )
iS f

subject to

iS f

(83)

(cid:12)
(i  

jS f

Hence we only have to update the linear term by the coupling
j )(cid:4)xi , x j(cid:5) and
( j  
i ). It is easy to see
that maximizing (83) also decreases (43) by exactly the same
amount. If we choose variables for which the KKTconditions
are not satised the overall objective function tends to decrease
whilst still keeping all variables feasible. Finally it is bounded
from below.

Even though this does not prove convergence (contrary to
statement in Osuna, Freund and Girosi (1997)) this algorithm
proves very useful in practice. It is one of the few methods (be-
sides (Kaufman 1999, Platt 1999)) that can deal with problems
whose quadratic part does not completely t into memory. Still
in practice one has to take special precautions to avoid stalling
of convergence (recent results of Chang, Hsu and Lin (1999)
indicate that under certain conditions a proof of convergence is
possible). The crucial part is the one of Sw.

B.2. A note on optimality

For convenience the KKT conditions are repeated in a slightly
modied form. Denote i the error made by the current estimate

Rewriting the feasibility conditions (52) in terms of  yields

for all i  {1, . . . , m} with zi , z
feasible variables z, s is given by


i


i


i

(85)

 z


, si , s
i

i ) +  + i + s

2i T (i ) +   i + si  zi = 0
= 0
i T (
2
 0. A set of dual
(cid:9)
(cid:8)
2i T (i ) +   i , 0
(cid:9)
2i T (i ) +   i , 0
(cid:8)
i ) +  + i , 0
i T (
2
i ) +  + i , 0
i T (
2

(cid:8)
zi = max
(cid:8)
si =  min
= max

z
i
=  min

s
i

(cid:9)
(cid:9)

(86)

Consequently the KKT conditions (53) can be translated into


i

and

and

(87)

(C  i )si = 0
(C  
= 0

i )s
i

i zi = 0
= 0

i z
All variables i , 
i violating some of the conditions of (87) may
be selected for further optimization. In most cases, especially in
the initial stage of the optimization algorithm, this set of pat-
terns is much larger than any practical size of Sw. Unfortunately
Osuna, Freund and Girosi (1997) contains little information on
how to select Sw. The heuristics presented here are an adaptation
of Joachims (1999) to regression. See also Lin (2001) for details
on optimization for SVR.

B.3. Selection rules

Similarly to a merit function approach (El-Bakry et al. 1996) the
idea is to select those variables that violate (85) and (87) most,
thus contribute most to the feasibility gap. Hence one denes a
score variable i by

i := gi zi + si ti
= i zi + 
i z

(cid:12)


i

+ (C  i )si + (C  

i )s
i

(88)

i

i is the size of the feasibility gap (cf. (56)
By construction,
for the case of -insensitive loss). By decreasing this gap, one
approaches the the solution (upper bounded by the primal objec-
tive and lower bounded by the dual objective function). Hence,
the selection rule is to choose those patterns for which i is

A tutorial on support vector regression

217

largest. Some algorithms use

C.2. Analytic solution for regression

i := i (zi ) + 
 (cid:12)

i


i )

(z

+ (C  i )(si ) + (C  

i )(si )

(89)

or

 (cid:12)(cid:12)

i

:= (i )zi + (
i )z


i

+ (C  i )si + (C  

i )si .

= 0 mutually imply each
One can see that i = 0,  (cid:12)
other. However, only i gives a measure for the contribution of
the variable i to the size of the feasibility gap.

= 0, and  (cid:12)(cid:12)

i

i

the boundaries,

Finally, note that heuristics like assigning stickyags (cf.
Burges 1998) to variables at
thus effec-
tively solving smaller subproblems, or completely removing
the corresponding patterns from the training set while ac-
counting for their couplings (Joachims 1999) can signi-
cantly decrease the size of the problem one has to solve and
thus result in a noticeable speedup. Also caching (Joachims
1999, Kowalczyk 2000) of already computed entries of the
dot product matrix may have a signicant
impact on the
performance.

Appendix C: Solving the SMO equations

C.1. Pattern dependent regularization

Consider the constrained optimization problem (83) for two in-
dices, say (i, j). Pattern dependent regularization means that Ci
may be different for every pattern (possibly even different for
i and 
i ). Since at most two variables may become nonzero
at the same time and moreover we are dealing with a con-
strained optimization problem we may express everything in
terms of just one variable. From the summation constraint we
obtain
(i  

:= 
(90)
 [L , H].
for regression. Exploiting ()
This is taking account of the fact that there may be only four
different pairs of nonzero variables: (i ,  j ), (
,  j ), (i , 
j ),
and (
j ). For convenience dene an auxiliary variables s
such that s = 1 in the rst and the last case and s = 1 other-
wise.

i ) + ( j  

j ] yields ()

j ) =(cid:8)

(cid:9) +(cid:8)

 [0, C ()

 

 

, 

old

old

(cid:9)

old

old

i

i

j

j

j

i

i

i

i


i

L
H
L
H

 j
max(0,   C j )
min(Ci ,  )
max(0, )
min(C

, + C j )


i



j


j

max(0,  )
+  )
min(Ci , C
max(0,  C

j )
min(C

, )


i

Next one has to solve the optimization problem analytically. We
make use of (84) and substitute the values of i into the reduced
optimization problem (83). In particular we use
yi 

i )Ki j = i + b +

(i  

(cid:2)

(cid:2)

 

Ki j .

old

(cid:8)

(cid:9)

old

i

i

j(cid:14)Sw

jSw

(91)

j

i

= 0):

+ j 

Moreover with the auxiliary variables  = i 
j and
 := (Kii + K j j  2Ki j ) one obtains the following constrained
optimization problem in i (after eliminating j, ignoring terms
=
independent of  j , 
 j 
maximize  1
(i  
i )2  (i + 
i )(1  s)
(cid:8)
(cid:8)
2
+ (i  
 
i   j + 
i )
 [L (), H ()].

j and noting that this only holds for i 
(cid:9)(cid:9)

subject to
The unconstrained maximum of (92) with respect to i or 
can be found below.

()

(92)

old

old

i

i

i

i

i

(I)
(II)
(III)
(IV)

i ,  j
i , 
j

,  j

, 

i

i

j

i

+ 1(i   j )
+ 1(i   j  2)
old  1(i   j + 2)
old  1(i   j )

old
old



i

i

i

The problem is that we do not know beforehand which of the
four quadrants (I)(IV) contains the solution. However, by con-
sidering the sign of  we can distinguish two cases: for  > 0
only (I)(III) are possible, for  < 0 the coefcients satisfy one
of the cases (II)(IV). In case of  = 0 only (II) and (III) have
to be considered. See also the diagram below.

For  > 0 it is best to start with quadrant (I), test whether the
unconstrained solution hits one of the boundaries L , H and if so,
probe the corresponding adjacent quadrant (II) or (III).  < 0
can be dealt with analogously.

Due to numerical instabilities, it may happen that  < 0. In
that case  should be set to 0 and one has to solve (92) in a linear
fashion directly.11

218

Smola and Scholkopf

C.3. Selection rule for regression

Acknowledgments

Finally, one has to pick indices (i, j) such that the objective
function is maximized. Again, the reasoning of SMO (Platt 1999,
Section 12.2.2) for classication will be mimicked. This means
that a two loop approach is chosen to maximize the objective
function. The outer loop iterates over all patterns violating the
KKT conditions, rst only over those with Lagrange multipliers
neither on the upper nor lower boundary, and once all of them
are satised, over all patterns violating the KKT conditions, to
ensure self consistency on the complete dataset.12 This solves
the problem of choosing i.

Now for j: To make a large step towards the minimum, one
looks for large steps in i . As it is computationally expensive to
compute  for all possible pairs (i, j) one chooses the heuristic to
maximize the absolute value of the numerator in the expressions
i , i.e. |i   j| and |i   j  2|. The index j
for i and 
corresponding to the maximum absolute value is chosen for this
purpose.

If this heuristic happens to fail, in other words if little progress
is made by this choice, all other indices j are looked at (this is
what is called second choice hierarcy in Platt (1999) in the
following way:

1. All indices j corresponding to nonbound examples are

looked at, searching for an example to make progress on.

2. In the case that the rst heuristic was unsuccessful, all
other samples are analyzed until an example is found where
progress can be made.

3. If both previous steps fail proceed to the next i.

For a more detailed discussion (see Platt 1999). Unlike interior
point algorithms SMO does not automatically provide a value
for b. However this can be chosen like in Section 1.4 by having
a close look at the Lagrange multipliers ()

i obtained.

C.4. Stopping criteria

By essentially minimizing a constrained primal optimization
problem one cannot ensure that the dual objective function in-
creases with every iteration step.13 Nevertheless one knows that
the minimum value of the objective function lies in the interval
, primal objectivei ] for all steps i, hence also in
[dual objectivei
the interval [(max ji dual objective j ), primal objectivei ]. One
uses the latter to determine the quality of the current solution.
The calculation of the primal objective function from the pre-

diction errors is straightforward. One uses

This work has been supported in part by a grant of the DFG
(Ja 379/71, Sm 62/1). The authors thank Peter Bartlett, Chris
Burges, Stefan Harmeling, Olvi Mangasarian, Klaus-Robert
Muller, Vladimir Vapnik, Jason Weston, Robert Williamson, and
Andreas Ziehe for helpful discussions and comments.

Notes

1. Our use of the term regression is somewhat lose in that it also includes
cases of function estimation where one minimizes errors other than the mean
square loss. This is done mainly for historical reasons (Vapnik, Golowich
and Smola 1997).

2. A similar approach, however using linear instead of quadratic programming,
was taken at the same time in the USA, mainly by Mangasarian (1965, 1968,
1969).

3. See Smola (1998) for an overview over other ways of specifying atness of

such functions.

4. This is true as long as the dimensionality of w is much higher than the
number of observations. If this is not the case, specialized methods can
offer considerable computational savings (Lee and Mangasarian 2001).

5. The table displays CT() instead of T () since the former can be plugged

directly into the corresponding optimization equations.

6. The high price tag usually is the major deterrent for not using them. Moreover
one has to bear in mind that in SV regression, one may speed up the solution
considerably by exploiting the fact that the quadratic form has a special
structure or that there may exist rank degeneracies in the kernel matrix
itself.

7. For large and noisy problems (e.g. 100.000 patterns and more with a substan-
tial fraction of nonbound Lagrange multipliers) it is impossible to solve the
problem exactly: due to the size one has to use subset selection algorithms,
hence joint optimization over the training set is impossible. However, unlike
in Neural Networks, we can determine the closeness to the optimum. Note
that this reasoning only holds for convex cost functions.

8. A similar technique was employed by Bradley and Mangasarian (1998) in

the context of linear programming in order to deal with large datasets.

9. Due to length constraints we will not deal with the connection between
Gaussian Processes and SVMs. See Williams (1998) for an excellent
overview.

10. Strictly speaking, in Bayesian estimation one is not so much concerned about
f of p( f | X) but rather about the posterior distribution of

the maximizer
f .
condition: 0  (cid:7)(xi )  (x j )(cid:7)2 = Kii + K j j  2Ki j = .

11. Negative values of  are theoretically impossible since k satises Mercers

12. It is sometimes useful, especially when dealing with noisy data, to iterate
over the complete KKT violating dataset already before complete self con-
sistency on the subset has been achieved. Otherwise much computational
resources are spent on making subsets self consistent that are not globally
self consistent. This is the reason why in the pseudo code a global loop
is initiated already when only less than 10% of the non bound variables
changed.

13. It is still an open question how a subset selection optimization algorithm
could be devised that decreases both primal and dual objective function
at the same time. The problem is that this usually involves a number of
dual variables of the order of the sample size, which makes this attempt
unpractical.

(cid:2)
(i  

(cid:2)

i )( j  

j )ki j = 

(i  

i )(i + yi  b),

