There’s an old joke, well known in database circles, to the effect that what users really want (and always have wanted, ever since database systems were first invented) is for somebody to implement the go faster! command. Well, I’m glad to be able to tell you that, as of now, somebody finally has ... This book is all about a radically new database implementation technology, a technology that lets us build database management systems (DBMSs) that are “blindingly fast”—certainly orders of magnitude faster than any previous system. As explained in the preface, that technology is known as The TransRelationaltm Model, or the TR model for short (the terms TR technology and, frequently, just TR are also used). As also explained in the preface, the technology is the subject of a United States patent (U.S. Patent No. 6,009,432, dated December 28th, 1999), listed as reference [63] in Appendix B at the back of this book; however, that reference is usually known more specifically as the Initial Patent, because several follow-on patent applications have been applied for at the time of writing. This book covers material from the Initial Patent and from certain of those follow-on patents as well.
The TR model really is a breakthrough. To say it again, it allows us to build DBMSs that are orders of magnitude faster than any previous system. And when I say “any previous system,” I don’t just mean previous relational systems. It’s an unfortunate fact that many people still believe that the fastest relational system will never perform as well as the fastest nonrelational system. Indeed, it’s exactly that belief that accounts in large part for the continued existence and use of older, nonrelational systems such as IMS [25,57] and IDMS [14,25], despite the fact that—as is well known—relational systems are far superior from the point of view of usability, productivity, and the like. However, a relational system implemented using TR technology should dramatically outperform even the fastest of those older nonrelational systems, finally giving the lie to those old performance arguments and making them obsolete (not before time, either).
I must also make it clear that I don’t just mean that queries should be faster under TR (despite the traditional emphasis in relational systems on queries in particular)—updates should be faster as well. Nor do I mean that TR is suitable only for decision support systems—it’s eminently suitable for transaction processing systems, too (though it’s probably fair to say that TR is particularly suitable for systems in which read-only operations predominate, such as data warehouse and data mining systems).
And one last preliminary remark: You’re probably thinking that the performance advantages I’m claiming must surely come at a cost: perhaps poor usability, or less functionality, or something (there’s no free lunch, right?). Well, I’m pleased to be able to tell you that such is not the case. The fact is, TR actually provides numerous additional benefits, over and above the performance benefit—for example, in the areas of database and system administration. Thus, I certainly don’t want you to think that performance is the only argument in favor of TR. We’ll take a look at some of those additional benefits in Chapters 2 and 15, and elsewhere in passing. (In fact, a detailed summary of all of the TR benefits appears in Chapter 15, in Section 15.4. You might like to take a quick look at that section right now, just to get an idea of how much of a breakthrough the TR model truly is.)
As I said in the preface, I believe TR technology is one of the most significant advances—quite possibly the most significant advance—in the data management field since E. F. Codd first invented the relational model (which is to say, since the late 1960s and early 1970s; see references [5 7], also reference [35]). As I also said in the preface, TR represents among other things a highly effective way to implement the relational model, as I hope to show in this book. In fact, the TR model—or, rather, the more general technology of which the TR model is just one specific but important manifestation—represents an effective way to implement data management systems of many different kinds, including but not limited to the following:
■■SQL DBMSs 	■■Data warehouse systems
■■Information access tools	■■Data mining tools
■■Object/relational DBMSs	■■Web search engines
■■Main-memory DBMSs	■■Temporal DBMSs
■■Business rule systems	■■Repository managers
■■XML document storage and retrieval systems	■■Enterprise resource planning tools
as well as relational DBMSs in particular. Informally, we could say we’re talking about a backend technology that’s suitable for use with many different frontends. In planning this book, however, I quickly decided that my principal focus should be on the application of the technology to implementing the relational model specifically. Here are some of my reasons for that decision:
■Concentrating on one particular application should make the discussions and examples more concrete and therefore, I hope, easier to follow and understand.
■■More significantly, the relational model is of fundamental importance; it’s rock solid, and it will endure. After all, it really is the best contender, so far as we know, for the role of “proper theoretical foundation” for the entire data management field. One hundred years from now, I fully expect database systems still to be firmly based on Codd’s relational model—even if they’re advertised as “object/relational,” or “temporal,” or “spatial,” or whatever. See Chapter 15 for further discussion of such matters. 
■■If your work involves data management in any of its aspects, then you should already have at least a nodding acquaintance with the basic ideas of the relational model. Though I feel bound to add that if that “nodding acquaintance” is based on a familiarity with SQL specifically, then you might not know as much as you should about the model as such, and you might know “some things that ain’t so.” I’ll come back to this point in a few moments. 
■■The relational model is an especially good fit with TR ideas; I mean, it’s a very obvious candidate for implementation using those ideas. Why? Because the relational model is at a uniform, and high, level of abstraction; it’s concerned purely with what a database system is supposed to look like to the user, and has absolutely nothing to say about what the system might look like internally. As many people would put it, the relational model is logical, not physical.