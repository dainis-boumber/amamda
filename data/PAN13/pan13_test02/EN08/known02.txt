The main purpose of this chapter is to explain in more detail some of the problems that arise in connection with what the lawyers call “prior art”—meaning, in the case at hand, systems that use the traditional direct-image approach to implementation. Of course, you can skip this material if you’re already familiar with conventional implementation technology. However, this first section does also introduce a few simple relational ideas, and you might at least want to make sure you’re familiar with those and fully understand them. 
Consider Fig. 2.1, which depicts a relation called S (“suppliers”). Observe that each supplier has a supplier number (S#), unique to that supplier;1 a supplier name (SNAME), not necessarily unique (though in fact the sample names shown in the figure do happen to be unique); a rating or status value (STATUS); and a location (CITY). I’ll use this example to remind you of a few of the most fundamental relational terms and concepts.
■First of all, a relation can, obviously enough, be pictured as a table. However, a relation is not a table.2 A picture of a thing isn’t the same as the thing! In fact, the difference between a thing and a picture of that thing is another of the great logical differences (see the remarks on this latter notion in Chapter 1, near the beginning of Section 1.3). One problem with thinking of a relation as a table is that it suggests that certain properties of tables—for example, the property that the rows are in a certain top-to-bottom order—apply to relations too, when in fact they don’t (see below). 
■■Each of the five suppliers is represented by a tuple (pronounced as noted in Chapter 1 to rhyme with “couple”). Tuples are depicted as rows in figures like Fig. 2.1, but tuples aren’t rows. 
■■Each supplier tuple contains four values, called attribute values; that is, the suppliers relation involves four attributes, called S#, SNAME, STATUS, and CITY. Attributes are depicted as columns in figures like Fig. 2.1, but attributes aren’t columns.
■■Attributes are defined over data types (types for short, also known as domains), meaning that every value of the attribute in question is required to be a value of the type in question. Types can be either system-defined (built in) or user-defined. For example, attribute STATUS might be defined over the system-defined type INTEGER (STATUS values are integers), while attribute SNAME might be defined over the user-defined type NAME (SNAME values are names). Note: For definiteness, I’ll assume these specific types throughout what follows, where it makes any difference. I’ll also assume that attribute S# is defined over a user-defined type with the same name (that is, S#), and attribute CITY is defined over the system-defined type CHAR (meaning character strings of arbitrary length). 
■■The tuples of a relation are all distinct. In fact, relations never contain duplicate tuples—the tuples of a relation form a mathematical set, and sets in mathematics don’t contain duplicate elements. Note: People often complain about this aspect of the relational model, but in fact there are good practical reasons for not permitting duplicate tuples. A detailed discussion of the point is beyond the scope of this book; see any of references [13], [20], or [33] if you want to pursue the matter. 
■■There’s no top-to-bottom ordering to the tuples of a relation. Although figures like Fig. 2.1 clearly suggest there is such an ordering, there really isn’t—to say it again, the tuples of a relation form a mathematical set, and sets in mathematics have no ordering to their elements. Note: It follows from this point that we could draw several different pictures that would all represent the same relation. An analogous remark applies to the point immediately following.
■There’s no left-to-right ordering to the attributes of a relation. Again, figures like Fig. 2.1 clearly suggest there is such an ordering, but there really isn’t; like the tuples, the attributes of a relation form a set, and thus have no ordering. (By the same token, there’s no left-to-right ordering to the components of a tuple, either.) No relation can have two or more attributes with the same name. 
■■The suppliers relation is in fact a base relation specifically. In general, we distinguish between base and derived relations; a derived relation is one that is derived from, or defined in terms of, other relations, and a base relation is one that isn’t derived in this sense. Loosely speaking, in other words, the base relations are the “given” ones—they’re the ones that make up the actual database—while the derived ones are views, snapshots, query results, and the like [33]. For example, given the base relation of Fig. 2.1, the result of the query “Get suppliers in London” is a derived relation that looks like this:
Another way to think about the distinction is that base relations exist in their own right, while derived ones don’t—they’re existence-dependent on the base relations. 
■■Every relation has at least one candidate key (or just key for short), which serves as a unique identifier for the tuples of that relation. In the case of the suppliers relation (and the derived relation just shown as well), there’s just one key, namely {S#}, but relations can have any number of keys, in general. Note: It’s important to understand that keys are always sets of attributes (though the set in question might well contain just a single attribute). For this reason, in this book I’ll always show key attributes enclosed in braces, as in the case at hand—braces being used by convention to bracket the elements that make up a set. 
■■As you probably know, it’s customary (though not obligatory) to choose, for any given relation, one of that relation’s candidate keys—possibly its sole candidate key—as primary; thus, for example, we might say in the case of the suppliers relation that {S#} is not just a key but the “primary” key. In figures like Fig. 2.1, I’ll follow the convention of identifying primary key attributes by double underlining. 
■■Finally, relations can be operated on by a variety of relational operators. In general, a relational operator is an operator that takes zero or more relations as input and produces a relation as output. Examples include the well-known operators restrict, project, join, and so on.