Many problems in Artificial Intelligence (AI) can be formulated as network search problems. The crudest
algorithms for solving problems of this kind, the so called blind search algorithms, use the network’s connectivity
information only. We are going to consider examples, applications and Prolog implementations of blind search
algorithms in this chapter.
Since implementing solutions of problems based on search usually involves code of some complexity, modularization
will enhance clarity, code reusability and readibility. In preparation for these more complex tasks in
this chapter, Prolog’s module system will be discussed in the next section.
In some (mostly larger) applications there will be a need to use several input files for a Prolog project. We have
met an example thereof already in Fig. 3.5 of [9, p. 85] where consult/1 was used as a directive to include in
the database definitions of predicates from other than the top level source file. As a result, all predicates thus
defined became visible to the user: had we wished to introduce some further predicates, we would have had to
choose the names so as to avoid those already used. Clearly, there are situations where it is preferable to make
available (that is, to export ) only those predicates to the outside world which will be used by other non-local
predicates and to hide the rest. This can be achieved by the built-in predicates module/2 and use module/1 .
As an illustrative example, consider the network in Fig. 2.1.1 The network connectivity in links.pl is
defined by the predicate link/2 which uses the auxiliary predicate connect/2 (Fig. 2.2).
The first line of links.pl is the module directive indicating that the module name is edges and that the
predicate link/2 is to be exported. All other predicates defined in links.pl (here: connect/2) are local to
the module and (normally) not visible outside this module.
Suppose now that in some other source file, link/2 is used in the definition of some new predicate (Fig. 2.3).
Then, the (visible) predicates from links.pl will be imported by means of the directive
The new predicate thus defined may be used as usual:
In our example, the predicate connect/2 will not be available for use (since it is local to the module edges
that resides in links.pl). A local predicate may be accessed, however, by prefixing its name by the module
name in the following fashion:3
Let us assume that for the network in Fig. 2.1 we want to find a path from the start node s to the goal node
g. The search may be conducted by using the (associated) search tree shown in Fig. 2.4. It is seen that the
search tree is infinite but highly repetitive. The start node s is at the root node (level 0). At level 1, all tree
nodes are labelled by those network nodes which can be reached in one step from the start node. In general, a
node labelled n in the tree at level _ has successor (or child ) nodes labelled s1, s2, . . . if the nodes s1, s2, . . . in
the network can be reached in one step from node n. These successor nodes are said to be at level _ + 1. The
node labelled n is said to be a parent of the nodes s1, s2, . . .. In Fig. 2.4, to avoid repetition, those parts of the
tree which can be generated by expanding a node from some level above have been omitted.
Some Further Terminology
• The connections between the nodes in a network are called links.
• The connections in a tree are called branches.
• In a tree, a node is said to be the ancestor of another if there is a chain of branches (upwards) which
connects the latter node to the former. In a tree, a node is said to be a descendant of another node if the
latter is an ancestor of the former.
In Fig. 2.5 we show, for later reference, the fully developed (and ’pruned’) search tree. It is obtained from
Fig. 2.4 by arranging that in any chain of branches (corresponding to a path in the network) there should be
no two nodes with the same label (implying that in the network no node be visited more than once). All
information pertinent to the present problem is recorded thus in the file links.pl (Fig. 2.2) by link/2. Notice
that the order in which child nodes are generated by link/2 will govern the development of the trees in Figs. 2.4
and 2.5: children of the same node are written down from left to right in the order as they would be obtained
by backtracking; for example, the node labelled d at level 1 in Fig. 2.4 is expanded by
(The same may be deduced, of course, by inspection from links.pl, Fig. 2.2.) link/2 will serve as input to
the implementations of the search algorithms to be discussed next.
The most concise and easy to remember illustration of Depth First is by the conduit model (Fig. 2.6). We start
with the search tree in Fig. 2.5 which is assumed to be a network of pipes with inlet at the root node s. The
tree is rotated by 90◦ counterclockwise and connected to a valve which is initially closed. The valve is then
opened and the system is observed as it gets flooded under the influence of gravity. The order in which the
nodes are wetted corresponds to Depth First.
We may be tempted to use Prolog’s backtracking mechanism to furnish a solution by recursion; our attempt is
shown in Fig. 2.7.4 However, it turns out that the implementation does not work due to cycling in the network.
The query shown below illustrates the problems arising.
We implement Depth First search incrementally using a new approach. The idea is keeping track of the nodes
to be visited by means of a list, the so called list of open nodes, also called the agenda. This book–keeping
measure will turn out to be amenable to generalization; in fact, it will be seen that the various search algorithms
differ only in the way the agenda is updated.