Now (at last) I can begin to explain the TR model in detail. As I mentioned several times in Part I, TR is indeed still a model, and thus, like the relational model, still somewhat abstract. At the same time, however, it’s at a much lower level of abstraction than the relational model; it can be thought of as being closer to the physical implementation level (“closer to the metal”), and accordingly more oriented toward issues of performance. In particular, it relies heavily on the use of pointers—a concept deliberately excluded from the relational model, of course, for reasons discussed in references [9], [30], [40], and many other places—and its operators are much more procedural in nature than those of the relational model. (What I mean by this latter remark is that code that makes use of those operators is much more procedural than relational code is, or is supposed to be.) What’s more, reference [63] includes detailed, albeit still somewhat abstract, algorithms for implementing those operators. Note: These remarks aren’t meant to be taken as criticisms, of course; I’m just trying to capture the essence of the TR model by highlighting some of its key features. 
Despite its comparatively low-level nature, the fact remains that, to say it again, TR is indeed a model, and thus capable of many different physical realizations. In what follows, I’ll talk for much of the time in terms of just one possible realization—it’s easier on the reader to be concrete and definite—but I’ll also mention some alternative implementation schemes on occasion. Note that the alternatives in question have to do with the implementation of both data structures and corresponding access algorithms. In particular, bear in mind that both main-memory and secondary-storage implementations are possible. 
Now, this book is meant to be a tutorial; accordingly, I want to focus on showing the TR model in action (as it were)—that is, showing how it works in terms of concrete examples—rather than on describing the abstract model as such. Also, many TR features are optional, in the sense that they might or might not be present in any given implementation or application of the model, and it’s certainly not worth getting into all of those optional features in a book of this kind. Nor for the most part is it worth getting into the optionality or otherwise of those features that are discussed—though I should perhaps at least point out that options do imply a need for decisions: Given some particular option X, some agency, at some time, has to decide whether or not X should be exercised. For obvious reasons, I don’t want to get into a lot of detail on this issue here, either. Suffice it to say that I don’t think many of those decisions, if any at all, should have to be made at database design time (by some human being) or at run time (by the system itself); in fact, I would expect most of them to be made during the process of designing the DBMS that is the specific TR implementation in question. In other words, I don’t think the fact that those decisions do have to be made implies that a TR implementation will therefore suffer from the same kinds of problems that arise in connection with direct-image systems, as discussed in Chapter 2. 
It follows from all of the above that this book is meant as an introduction only; many topics are omitted and others are simplified, and I make no claims of completeness of any kind.
Now let’s get down to business. In this chapter and the next,1 we’ll be looking at what are clearly the most basic TR constructs of all: namely, the Field Values Table and the Record Reconstruction Table, both of which were mentioned briefly in the final section of the previous chapter. These two constructs are absolutely fundamental—everything else builds on them, and I recommend as strongly as I can that you familiarize yourself with their names and basic purpose before you read much further. Just to remind you: 
■■The Field Values Table contains the field values from a given file, rearranged in a way to be explained in Section 4.3. 
■■The Record Reconstruction Table contains information that allows records of the given file to be reconstructed from the Field Values Table, in a way to be explained in Section 4.4. 
In subsequent chapters I’ll consider various possible refinements of those core concepts. Note: Those refinements might be regarded in some respects as “optional extras” or “frills,” but some of them are very important—so much so, that they’ll almost certainly be included in any concrete realization of the TR model, as we’ll see.
Let r be some given record within some given file at the file level. Then the crucial insight underlying the TR model can be characterized as follows: 
The stored form of r involves two logically distinct pieces, a set of field values and a set of “linkage” information that ties those field values together, and there’s a wide range of possibilities for physically storing each piece. 
In direct-image systems, the two pieces (the field values and the linkage information) are kept together, of course; in other words, the linkage information in such systems is represented by physical contiguity. In TR, by contrast, the two pieces are kept separate; to be specific, the field values are kept in the Field Values Table, and the linkage information is kept in the Record Reconstruction Table. That separation makes TR strikingly different from virtually all previous approaches to implementing the relational model (see Chapters 1 and 2), and is the fundamental source of the numerous benefits that TR technology is capable of providing. In particular, it means that TR data representations are categorically not a direct image of what the user sees at the relational level. 
Note: One immediate advantage of the separation is that the Field Values Table and the Record Reconstruction Table can both be physically stored in a way that is highly efficient in terms of storage space and access time requirements. However, we’ll see many additional advantages as well, both in this chapter and in subsequent ones.