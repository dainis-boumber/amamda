Using the File Manager (in KDE, Konqueror or in Gnome, Nautilus) create a new directory
somewhere in your home directory called something appropriate for all the examples in this book,
perhaps “Programming_In_Linux” without any spaces in the name.
Open an editor (in KDE, kate, or in Gnome, gedit) and type in (or copy from the supplied source code
zip bundle) the following:
Save the text as chapter1_1.c in the new folder you created in your home directory.
Open a terminal window and type: gcc -o hello chapter1_1.c
to compile the program into a form that can be executed.
Now type “ls -l” to list the details of all the files in this directory. You should see that chapter1_2.c is
there and a file called “hello” which is the compiled C program you have just written.
Now type: ./hello
to execute, or run the program and it should return the text:
"Hello you are learning C!!".
If this worked, congratulations, you are now a programmer!
The part inside /*** ***/ is a comment and is not compiled but just for information and
reference.
The “#include...” part tells the compiler which system libraries are needed and which header files
are being referenced by this program. In our case “printf” is used and this is defined in the
stdio.h header.
The “int main(int argc, char *argv[])” part is the start of the actual program. This is an entrypoint
and most C programs have a main function.
The “int argc” is an argument to the function “main” which is an integer count of the number of
character string arguments passed in “char *argv[]” (a list of pointers to character strings) that
might be passed at the command line when we run it.
A pointer to some thing is a name given to a memory address for this kind of data type. We can
have a pointer to an integer: int *iptr, or a floating point number: float *fPtr. Any list of things is
described by [], and if we know exactly how big this list is we might declare it as [200]. In this
case we know that the second argument is a list of pointers to character strings.
Everything else in the curly brackets is the main function and in this case the entire program
expressed as lines.
Each line or statement end with a semi-colon “;”.
We have function calls like “printf(...)” which is a call to the standard input / output library
defined in the header file stdio.h.
At the end of the program “return 0” ends the program by returning a zero to the system.
Return values are often used to indicate the success or status should the program not run
correctly.
Taking this example a stage further, examine the start of the program at the declaration of the entry
point function: int main(int argc, char *argv[])
In plain English this means:
The function called “main”, which returns an integer, takes two arguments, an integer called “argc”
which is a count of the number of command arguments then *argv[] which is a list or array of pointers
to strings which are the actual arguments typed in when you run the program from the command line.
Let's rewrite the program to see what all this means before we start to panic.
Save the text as chapter1_2.c in the same folder.
Open a terminal window and type:
gcc -o hello2 chapter1_2.c to compile the program into a form that can be executed.
Now type ls -l to list the details of all the files in this directory. You should see that chapter1_2.c is
there and a file called hello2 which is the compiled C program you have just written.
Now type ./hello2 to execute, or run the program and it should return the text:
We can see that the name of the program itself is counted as a command line argument and that the
counting of things in the list or array of arguments starts at zero not at one.
Now type ./hello2 my name is David to execute the program and it should return the text:
So, what is happening here? It seems we are reading back each of the character strings (words) that
were typed in to run the program.
Lets get real and run this in a web page. Make the extra change adding the first output printf statement
“Content-type:text/plain\n\n” which tells our server what kind of MIME type is going to be
transmitted.
Compile using gcc -o hello3 chapter1_3.c and copy the compiled file hello3 to your
public_html/cgi-bin directory (or on your own machine as superuser copy the program to
/srv/www/cgi-bin (OpenSuse) or /usr/lib/cgi-bin (Ubuntu)).
Open a web browser and type in the URL http://localhost/cgi-bin/hello3?david+haskins and you
should see that web content can be generated by a C program.
A seldom documented feature of the function signature for “main” is that it can take three arguments
and the last one we will now look at is char *env[ ] which is also a list of pointers to strings, but in this
case these are the system environment variables available to the program at the time it is run
Compile with gcc -o hello4 chapter1_4.c and as superuser copy the program to /srv/www/cgi-bin
(OpenSuse) or /usr/lib/cgi-bin (Ubuntu). You can run this from the terminal where you compiled it
with ./hello4 and you will see a long list of environment variables. In the browser when you enter
http://localhost/cgi-bin/hello4 you will a different set altogether.
We will soon find out that QUERY_STRING is an important environment variable for us in
communicating with our program and in this case we see it has a value of “david+haskins” or
everything after the “?” in the URL we typed. It is a valid way to send information to a common
gateway interface (CGI) program like hello4 but we should restrict this to just one string. In our case
we have used a “+” to join up two strings. If we typed: “david haskins” the browser would translate
this so we would see:
QUERY_STRING=david%20haskins
We will learn later how complex sets of input values can be transmitted to our programs.