Conciseness and accessibility of source code through declarative reading are Prolog’s major strengths. It is
therefore relatively easy to appreciate the workings of someone else’s implementation, while it is much harder
independently to arrive at one’s own solution to the same problem. In this chapter, we illustrate a practical
methodology which is intended to overcome this discrepancy: it is a software development style that is
interactive, incremental, exploratory and allows Prolog code to be arrived at in a relatively effortless manner.
The task is to write a Prolog predicate rhyme/0 which displays on the screen the well-known nursery rhyme
This is the House that Jack Built ([11]):
In our implementation of rhyme/0 we want to exploit the rhyme’s repetitive structure and the fact that
all essential information is contained in its last verse. We record the last verse in the database by verse/1 as
shown in (P-4.1).
The rhyme is seen roughly to match the simplified pattern shown in Fig. 4.1.
Knowing the rhyme’s last verse and the above structure will allow (up to some finer detail) the rhyme to
be fully reconstructed. With a view to a simplified preliminary Prolog implementation, we therefore define the
following Prolog fact in the database
The first task is now to define a predicate rhyme prel/2 which should enable us to obtain the skeleton rhyme’s
structure in the following manner.
Taking this as an informal specification of rhyme prel/2 , we want to arrive at its definition by a series of
interactive experiments.
What could be the least ambitious first step in implementing rhyme prel/2 ? We may for example create a list
whose only entry is the last entry of the above list-of-lists. (This will correspond to reproducing the last verse.)
This we do by
Still interactively, a list comprising the last two entries of the target list-of-lists may be generated by
Here we unify T1 with the tail of V and position it in front of V to form the new list (of lists). How do
we now generate the next larger list (comprising the last three entries of the target list-of-lists)? We proceed as
before except that we assemble R from the entries T2 , T1 and V (in that order!) where T2 is unified with
the tail of T1 .
One more such step should suffice to appreciate the underlying pattern of interactively generating instances of
R .
Since our aim is to identify a recursive pattern in the above interactive session, we recast the inputs slightly by
observing that [a1, • • • , an−1, an] and [a1|[a2|[a3| • • • |[an−1|[an]] • • • ]] are equivalent representations of the same
list. Let’s have a look at the last two queries again.
The annotated lists suggest the following pseudocode (using Prolog’s list-notation) for one single recursive
step.
Notice that by equations (4.1) and (4.2) we may replace the latter by
The base case for the recursion is given by
A straightforward implementation of the recursive step is by the (auxiliary) predicate rhyme aux/3 in (P-4.2).
In the first argument of rhyme aux/3 the most recent version of the rhyme is accumulated; its second argument
is a counter which is decremented from an initial value until it reaches unity at which point the third argument
is instantiated to the first. It is noteworthy in the definition of rhyme aux/3 that, as a consequence of using
the accumulator technique, reference to the more complex case in the recursive step is found in the rule’s body.
(In this sense, as opposed to the familiar situation from imperative programming, progression is from right to
left.)
We find out by an experiment what the counter should be initialized to.
It is seen that the second argument of rhyme aux/3 (the counter) will have to be initialized to the length of
(what stands for) the last verse. This gives rise to the following first version of the predicate rhyme prel/2
which then behaves as specified on p. 119.
Even though the solution thus obtained is perfectly acceptable, there is scope for improvement. Counters
are commonly used in imperative programming for verifying a stopping criterion. The corresponding task in
declarative programming is best achieved by pattern matching. There is indeed no need for a counter here since
the information for when not to apply the recursive step (any more) can be gleaned from the pattern of the
first argument of rhyme aux/3 : For the recursion to stop, the head of the list-of-lists (in the first argument)
should itself be a list with exactly one entry. (The complete rhyme will have been arrived at when the first
verse comprises a single line!) This idea gives rise in (P-4.3) to a new, improved (and more concise) version of
the auxiliary predicate, now called rhyme aux/3 .
rhyme aux 2/3 behaves as intended:
The definition of a second, improved version of the preliminary rhyme predicate now simplifies to
To complete the ‘skeleton version’ of the rhyme, we display the above by
with the predicate show rhyme/1 defined by
There is still scope for further improvement leading to an even more concise version of the auxiliary predicate.
We may replace in the definition of rhyme aux 2/2 all occurrences of Head Old by [H|T], say, accounting for
the fact that Head Old will be unified with a list.
But then, by virtue of the first goal in the body of this rule we may replace all occurrences of Head by T.
Subsequently, the first goal may be dropped. Overall, we obtain in (P-4.4) a third, even more concise version
of the auxiliary predicate.
There is hardly any room for improvement left save perhaps a minor simplification of the first clause. We derive
an alternative boundary case by first completing the interactive session from p. 120 and then carrying out one
more step:
The first query suggests that we are finished if the (partially) completed skeleton rhyme’s head is a single element
list; this condition gave rise to the earlier boundary case. On the other hand, in the second query the
variable R is unified with a list whose head is empty and whose tail is the full skeleton rhyme.