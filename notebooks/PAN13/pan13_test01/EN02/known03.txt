In order to understand the TR approach to implementing the relational model, it’s necessary to be very clear over three distinct levels of the system, which I’ll refer to as the three levels of abstraction (since each level is an abstraction of the one below, loosely speaking). The three levels, or layers, are: 
1. The relational (or user) level 
2. The file level 
3. The TR level
■Level 1, which corresponds to the database as seen by the user, is the relational level. At this level, the data is perceived as relations, including, perhaps, the suppliers relation S discussed in Section 2.1 (and illustrated in Fig. 2.1) in the previous chapter. 
■■Level 3 is the fundamental TR implementation level. At this level, data is represented by means of a variety of internal structures called tables. Please note immediately that those TR tables are NOT tables in the SQL sense and do NOT correspond directly to relations at the user level.
■Level 2 is a level of indirection between the other two. Relations at the user or relational level are mapped to files at this level, and those files are then mapped to tables at the TR level. Of course, the mappings go both ways; that is, tables at the TR level map to files at the next level up, and those files then map to relations at the top level. Note: As I’m sure you know, map is a synonym for transform (and I’ll be using the term in that sense throughout this book); thus, we’re already beginning to touch on the TR transforms that were mentioned in Chapter 1. However, there’s a great deal more to it, as we’ll soon see. 
Please now observe that each level has its own terminology: relational terms at the user level, file terms at the file level, and table terms at the TR level. Using different terms should, I hope, help you keep the three levels distinct and separate in your mind; for that reason, I plan to use the three sets of terms consistently and systematically throughout the rest of this book. 
Having said that, I now need to say too that I’m well aware that some readers might object to my choice of terms—perhaps even find them confusing—for at least the following two reasons: 
■■First, the industry typically uses the terminology of tables, not relations, at the user level—almost exclusively so, in fact. But I’ve already explained some of my rationale for wanting to use relational terms at that level (see the previous chapter, Section 2.1), and I’m going to give some additional reasons in the next section.
■Second, the industry also typically tends to think of files as a fairly “physical” construct. In fact, I did the same thing myself in the previous chapter, somewhat, though I was careful in that chapter always to be quite clear that the files I was talking about were indeed physically stored files specifically. By contrast, the files I’ll be talking about in the rest of the book are not physically stored; instead, they’re an abstraction of what’s physically stored, and hence a “logical” construct, not a physical one. (Though it wouldn’t be wrong to think of them as “slightly more physical” than the user-level relations, if you like.) 
If you still think my terms are confusing, then I’m sorry, but for better or worse they’re the terms I’m going to use. 
One final point: When I talk of three levels, or layers, of abstraction, I don’t mean that each of those levels is physically materialized in any concrete sense—of course not. The relational level is only a way of looking at the file level, a way in which certain details are ignored (that’s what “level of abstraction” means). Likewise, the file level in turn is only a way of looking at the TR level. Come to that, the TR level in turn is only a way of looking at the bits and bytes that are physically stored; that is, the TR level is itself—as already noted in Chapter 1, Section 1.2—still somewhat abstract. In a sense, the bits-and-bytes level is the only level that’s physically materialized.1
Since the focus of this book is on the use of TR technology to implement the relational model specifically, the topmost (user) level is relational by definition. In other words, the user sees the database as a set of relations, made up of attributes and tuples as explained in Chapter 2. For simplicity, I’m going to assume those relations are all base relations specifically (again, see Chapter 2); that is, I’ll simply assume, barring explicit statements to the contrary, that any relation that’s named and is included in the database is in fact a base relation specifically, and I won’t usually bother to use the “base” qualifier. 
Also, of course, the user at the relational level has available a set of relational operators—restrict, project, join, and so forth—for querying the relations in the database, as well as the usual INSERT, DELETE, and UPDATE operators for updating them. Note: If I wanted to be more precise here, I’d have to get into the important distinction between relation values and relation variables. Relational operators like join operate on relation values, while update operators like INSERT operate on relation variables. Informally, however, it’s usual to call them all just relations, and—somewhat against my better judgment—I’ve decided to follow that common usage (for the most part) in the present book. For further discussion of such matters, see either reference [32] or reference [40]. 
Now, given the current state of the IT industry, the user level in a real database system will almost certainly be based on SQL, not on the relational model. As a consequence, users will typically tend to think, not in terms of relational concepts as such, but rather in terms of SQL analogs of those concepts. For example, there isn’t any explicit project operator, as such, in SQL; instead, such an operation has to be formulated in terms of SQL’s SELECT and FROM operators, and the user has to think in terms of those SQL operators, as in this example (“Project suppliers over supplier number and city name”):