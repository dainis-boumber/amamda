This is the last chapter in this part of the book. In it, I want to describe a rather different approach to the problem of implementing the TR model on disk: more specifically, to the problem of minimizing disk seeks. Note immediately, therefore, that the approach in question can be regarded in part as an alternative to file banding as discussed in Chapter 13—but only in part, because in fact file banding can be used in combination with the approach to be described, as we’ll see in Section 14.4. Note too that, as with the discussion of file banding in Chapter 13, we’re primarily concerned here with how to deal with the “large file” that remains after file factoring has been used to get all of the “small files” into memory. But first things first. 
As we know, the basic problem with TR on the disk is that if we’re not careful, the zigzags can splay out all over the disk. Well, if the splay problem is caused by the zigzags, then let’s get rid of the zigzags! Recall from Chapter 5 (Section 5.8) that the linkage information that lets us reconstruct records doesn’t have to be implemented as zigzags specifically—other possibilities exist, with (of course) different performance characteristics. The approach to be described in this chapter exploits this idea; essentially, what it does is replace the zigzags by a different kind of structure called a star.

Let me illustrate this idea right away. Fig. 14.1 shows the Field Values Table and corresponding Record Reconstruction Table from Figs. 13.2 and 13.3 in Chapter 13—except that, for pedagogic reasons, I’ve shown the Field Values Table in uncondensed form. Fig. 14.2 then highlights one particular zigzag from Fig. 14.1 (actually the one for part P7), and Fig. 14.3 shows what happens if we replace that zigzag by a star.

As you can see, where Fig. 14.2 has a ring of pointers (implemented within the Record Reconstruction Table and conceptually superimposed on the Field Values Table), Fig. 14.3 has a star of pointers instead. Cell [7,1], which corresponds to the P# value P7, serves as the center or core of that star. Three pointers emanate from that core and point to cells [6,2], [8,3], and [4,4], respectively; those cells correspond to the PNAME value Nut, the WEIGHT value 19.0, and the CC# value cc1, respectively. Those three pointers, which (as Fig. 14.3 indicates) are all two-way and can therefore be traversed in either direction, serve as the spokes or rays of the star. 
Now, the star in the figure clearly does support reconstruction of the record for the part in question (part P7). To be specific: 
a) If we start at the core, we can simply follow the three spoke pointers outward to obtain the other three field values. 
b) If we start at any other point, we can follow the corresponding spoke pointer inward to the core and then proceed as under a) above—with the exception that, if we get to the core by following spoke pointer sp inward, then of course there’s no need to follow that particular spoke sp outward again. Note: As a matter of fact, we never need to follow a spoke outward from the core within the Record Reconstruction Table as such; we only need to be able to go from the core outward to cells within the Field Values Table. 
Now, you might have already realized that, for any given zigzag, there are several distinct but equivalent stars—it just depends on which field we choose as the core. I’ll return to this point in Section 14.3. You might also have realized that the record reconstruction algorithm as just outlined displays asymmetric performance—access via the core field will be faster than access via any other field, because stars (unlike zigzags) are an inherently asymmetric structure—and I’ll return to this point in Section 14.5. 
The structure of the chapter is as follows. Following this introductory section, Section 14.2 gives a simple example to illustrate the basic ideas behind star structures. Section 14.3 elaborates on and generalizes that example. Section 14.4 shows how the ideas from the first three sections work on the disk (those previous sections are principally concerned with a memory-based implementation only). Finally, Section 14.5 discusses the use of controlled redundancy in connection with star structures.

As in the previous chapter, the basic problem we’re trying to deal with is how to get the best possible performance out of the “large” Record Reconstruction Table in a disk-based system. So I’ll base my discussions on the same running example as in that previous chapter; to be specific, I’ll assume once again that we’ve factored the parts file into large and small files that look like this:

However, we’re interested here in the large file exclusively. Fig. 14.4 shows a sample value for that file (extracted from Fig. 13.1 in Chapter 13). And we’ve already seen a Field Values Table and a zigzag-based Record Reconstruction Table for that file in Fig. 14.1 above. Note: While the file shown in Fig. 14.4 is obviously not very large, let me remind you that we’re really supposed to be dealing with files of millions or even billions of records, and the data in those files isn’t supposed to display any “statistical clumpiness” at all.

Now, despite the fact that we’re really supposed to be talking about a disk implementation, it’s convenient to pretend for the time being that everything’s in memory, and I’ll adopt that pretense until further notice. So how do we proceed? Well, since (as we’ve already seen) stars are asymmetric, the first thing we have to do is decide what the core’s going to be; in other words, we first have to choose a core field (much as we had to choose a characteristic field in connection with with banding in the previous chapter).1 Suppose we choose field P#. Then Fig. 14.5 shows a corresponding star-based Record Reconstruction Table for the file of Fig. 14.4. Note: From this point forward, for convenience, I’ll abbreviate the term “star-based Record Reconstruction Table” to just star table, and similarly for zigzag table.