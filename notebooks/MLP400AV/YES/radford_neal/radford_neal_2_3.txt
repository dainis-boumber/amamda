Abstract

The probability of accepting a candidate move in the hybrid Monte Carlo algorithm
can be increased by considering a transition to be between windows of several states
at the beginning and end of the trajectory, with a state within the selected win-
dow being chosen according to the Boltzmann probabilities. The detailed balance
condition used to justify the algorithm still holds with this procedure, provided the
start state is randomly positioned within its window. The new procedure is shown
empirically to signicantly improve performance for a test system of uncoupled os-
cillators.

(Figures 2, 3, and 4 are not present in this version.)

1

1

Introduction

The hybrid Monte Carlo algorithm of Duane, Kennedy, Pendleton, and Roweth [2]
is a method of sampling from complex distributions, such as those encountered in
statistical physics, that combines the advantages of dynamical methods [1] with
those of the Metropolis Monte Carlo method [4]. These and related methods are
reviewed by Toussaint [5].

The problem is to simulate a system parameterized by a vector, q, of dimension
N , with a dierentiable potential energy function, E(q). This energy function
induces a Boltzmann distribution over q, for which the probability density is

p(q) = Z 1

E exp(E(q))

(1)

where ZE =RRN exp(E(q)) dq. (A temperature of one is assumed throughout, for

The aim of the simulation is to estimate the expectation of some function, h(q):

simplicity.)

hhi = ZRN

h(q) p(q) dq 

1
n

n1Xi=0

h(qi)

(2)

where q0, q1, . . . , qn1 are obtained from the simulation, and are each distributed
according to the Boltzmann distribution for q (but are not, in general, independent).
I will rst describe the dynamical approach to solving this problem, which suers
from systematic error in the sampling, and then describe the hybrid Monte Carlo
method, which eliminates this error by accepting only some of the dynamical moves.
Next, I present and justify a generalization of this algorithm in which moves are
made between windows of states at the beginning and end of a trajectory, rather
than between single states. Situations in which this algorithm will have a higher
acceptance probability than the standard algorithm are then illustrated, and an
empirical comparison is given for systems of uncoupled oscillators. Finally, I discuss
two variations on the algorithm that may be useful in some circumstances.

2 The dynamical method

In the dynamical simulation method, we introduce a momentum vector, p, which,
like q, has dimension N , and a Hamiltonian function, H(q, p), that incorporates
both potential and kinetic energy:

H(q, p) = E(q) + 1

2 |p|2

(3)

We then seek to sample from the Boltzmann distribution that H induces on the

phase space, (q, p), for which the density is

p(q, p) = Z 1

H exp(H(q, p)) = p(q) p(p)

(4)

2

where ZH =RRNRRN exp(H(q, p)) dq dp, and

p(p) = (2)N/2 exp( 1

2 |p|2)

(5)

This sample is generated by simulating an ergodic Markov chain that has the
Boltzmann distribution for (q, p) as its stationary distribution. Values of q from
successive states of this Markov chain, whose marginal distribution is that of equa-
tion (1), are used to estimate hhi using equation (2).

This Markov chain operates by alternating dynamical transitions with stochastic

transitions.

The dynamical transitions consist of simulating the system for some predened

period in a ctitious time,  , using Hamiltons equations:

dq
d

dp
d

= +

= 

H
p

H
q

= p

= E(q)

(6)

(7)

These equations leave H invariant. Furthermore, the volume of a region of phase
space remains constant as it evolves according to this dynamics (Liouvilles the-
orem).
In consequence, the dynamical transitions sample regions of constant H
without bias.

The stochastic transitions allow regions with dierent values of H to be explored.
They consist of replacing p with a value picked from its Boltzmann distribution
(equation (5)). Such transitions clearly leave the Boltzmann distribution of (q, p)
with respect to H invariant. The presence of these stochastic transitions will also
usually be enough to ensure that the Markov chain is ergodic  i.e. that the system
can move to any point in phase space.

It is generally desirable that the trajectories simulated in the dynamical tran-
sitions be long enough that they reach congurations almost independent of their
starting congurations. This avoids the slow exploration, at the rate of a random
walk, that would result if the direction of motion were frequently randomized by
stochastic transitions.

In practice, the dynamics must be simulated with some nite step size. The
leapfrog method is generally used, with the following steps being iterated some
predened number of times, L, with some specied step size, :

p( + 

2 ) = p( )  

2 E(q( ))

q( + ) = q( ) +  p( + 
2 )

p( + ) = p( + 

2 )  

2 E(q( + ))

(8)

(9)

(10)

This discretized mapping still preserves phase space volume exactly. However, with
a nite , it does not leave H exactly constant. This will introduce some systematic
error into the sampling.

3

3 The hybrid Monte Carlo algorithm

The systematic error of the dynamical method is eliminated in the hybrid Monte
Carlo algorithm [2] by considering the end-point of the trajectory found with the
leapfrog method to be merely a candidate for the next state of the Markov chain,
to be accepted or rejected as in the Metropolis Monte Carlo algorithm [4].

Acceptance or rejection of the candidate state is based on the amount, H, by
which H for the candidate state exceeds H for the current state. The probability
of acceptance, a(H), is given by

a(H) = min(1, exp(H))

(11)

Thus candidate states with lower H are always accepted, while those with higher
H are accepted with probability exp(H). If the candidate state is rejected, the
new state is the same as the current state (and is counted again in the average of
equation (2)).

The validity of this procedure for producing a sample from the Boltzmann distri-
bution is more easily seen if we imagine that the trajectory for a dynamical transition
is computed using a value for  whose sign is chosen at random, with positive and
negative values being equally likely. The leapfrog method (equations (8) to (10)) is
time-reversible, so that a forward trajectory, with a positive , and a backward
trajectory, with the corresponding negative , are inverses of each other, a fact cru-
cial to the justication of the algorithm. In fact, usual practice is to always use a
positive , since an eect equivalent to randomly choosing its sign is produced in
any case by the randomization of the direction of p in the stochastic transitions.

To show that the Boltzmann distribution (equation (4)) is invariant under such
dynamical transitions, it suces to show that these transitions satisfy the condition
known as detailed balance  that the probability of a transition from A to B
occurring is the same as that for a transition from B to A, given that the start state
is Boltzmann distributed.

To see that detailed balance holds, consider a small region of volume V around
the point A = (qA, pA). Suppose that a forward trajectory from A leads to the
point B = (qB, pB). The other points in the region around A will lead to a region
around B, which will also have volume V , since the leapfrog method preserves
phase space volume. Due to time reversibility, a backward trajectory from B will
lead to A. The detailed balance condition with respect to the regions around A and
B can now be written as

p(qA, pA) V  1

2  a(H(qB, pB)H(qA, pA))

= p(qB, pB) V  1

2  a(H(qA, pA)H(qB, pB))

(12)

The left side of the above equation is the probability of moving from the region
around A to the region around B. The rst factor is the Boltzmann probability for

4

being in the region around A at the start, the second factor ( 1
2 ) is the probability of
selecting a forward direction for the trajectory, and the third factor is the probability
that this trajectory will be accepted. The right side expresses the probability of
moving from the region around B to the region around A in analogous fashion. The
equality of these two probabilities is seen by substituting from equations (4) and
(11). The detailed balance condition can be similarly veried for the case where a
backward trajectory from A is chosen.

The Boltzmann distribution is also invariant with respect to the stochastic tran-
sitions, which simply replace p with a value chosen from its Boltzmann distribution.
Thus, if (as we expect) the Markov chain is ergodic, it will have the Boltzmann dis-
tribution as its unique stationary distribution.

4 An acceptance procedure using windows

The standard hybrid Monte Carlo algorithm can be generalized to consider a window
of states at the end of the trajectory as candidate destinations for a dynamical
transition, rather than just a single end state. In order to maintain detailed balance,
a possible move to this window must be considered in relation to an equal-sized
window around the current state, with the location of the current state within that
window being determined randomly. Due to this later requirement, the trajectory
may have to be computed for some number of steps in the reverse of its primary
direction. Acceptance or rejection of a move between windows is based on the total
probability of the states they contain. Whichever window is selected, a particular
state within that window is then picked according to the Boltzmann probabilities.
This procedure can signicantly increase the probability of accepting a move, as
will be discussed in Section 6. First, though, I will dene the algorithm in more
detail.

To begin, values for the total number of steps in the trajectory, L, the base step
size, 0, and the window size, W , are selected from some xed distribution, with
1  W  L + 1. A forward or backward direction, , for the trajectory is then
chosen, with equal probabilities for  = +1 and  = 1, and an oset, K, for the
current state within the start window is selected, with K  {0, . . . , W  1}, each
possible value being equally likely.

A reverse portion of the trajectory is then computed by applying the leapfrog
method with a step size of  = 0, beginning with the start state, X(0). This is
done for K iterations, producing states labeled X(1), . . . , X(K). The start state
is then restored, and the leapfrog method is applied with a step size of  = +0 for
L  K iterations, producing states X(1), . . . , X(L  K).

The reject window at the front of the trajectory, around the current state, is
dened as the set R = {X(K), . . . , X(K + W  1)}. The accept window at
the far end of the trajectory is dened as A = {X(L  K  W + 1), . . . , X(L  K)}.
These windows may overlap.

5

The free energy for a window is dened as follows:

F (W) =  log  XXW

exp(H(X))!

(13)

The free energies are used to decide whether the next state will come from the
accept window or the reject window. Using the acceptance function of equation (11),
the accept window is selected with probability a(F ) where F = F (A)  F (R);
otherwise we remain in the reject window (which contains the current state). Having
decided on the window W, a particular state within that window is then selected
according to the probabilities

P (X) = exp(H(X) + F (W))

(14)

The state selected becomes the next state in the Markov chain.

When implementing the generalized algorithm, it is not necessary to save all
the states in the accept and reject windows. One need only save the start state, so
it can be restored after the reversed portion of the trajectory has been calculated,
along with a single state from the accept window and a single state from the reject
window, one or the other of which will become the next state of the Markov chain.
A be the free energy for the rst i states that have been visited
in the accept window, and let C i
A be a state chosen according to the Boltzmann
probabilities from among these rst i states. These variables can be calculated
incrementally as new states in the accept window are visited. To start, F 0
A = 
and C 0
A is undened. When we visit the i-th state in the accept window, (qi, pi),
we can calculate

In detail, let F i

F i

C i

A )(cid:17)
A =  log(cid:16) exp(H(qi, pi)) + exp(F i1
A = ( C i1

with probability exp(F i1

A

(qi, pi) with probability exp(H(qi, pi) + F i

A)

A + F i

A)

(15)

(16)

Once all states have been visited, we will have F (A) = F W
A will be a state
picked from A according to the Boltzmann probabilities. Analogous variables, F i
R
and C i
R are maintained for the reject window. Once all states have been seen, a
decision as to whether to use the accept window or the reject window can easily be
made, and, in either case, a state selected from the chosen window is available.

A , and C W

When W = 1, the generalized algorithm is equivalent to the standard hybrid
Monte Carlo algorithm. When W = L + 1 the procedure reduces to simply picking a
state from those anywhere along the trajectory in accordance with their Boltzmann
probabilities. Some simplication in the implementation is then possible.

6

5 Validity of the generalized algorithm

To demonstrate the validity of the generalized algorithm, we need to show that the
detailed balance condition holds for the dynamical transitions. As L, W , and 0
are chosen from a xed distribution, independently of the current state, we may
choose to regard them as xed, since if detailed balance holds for transitions with
any values of these parameters, it will hold for a mixture of such transitions. It will
prove necessary to average over the values selected for  and K, however.

Detailed balance will be proved separately for transitions to a state in the accept
window and for those to a state in the reject window. If the two windows overlap,
as they will if W > (L + 1)/2, there will for some pairs of states be the possibility of
transitions of either type. If detailed balance holds for the two types of transitions
individually, however, it will also hold for the combination.

To prove detailed balance for transitions within the reject window, note rst that
the set of possible trajectories (for the various values of  and K) that start at state
A and that include state B in the reject window is the same as the set of trajectories
that start at B and include A in the reject window. Here, a trajectory is dened as
the set of states visited, along with the subsets of states that make up the accept and
reject windows. In detail, if for the trajectory starting at A = XA(0), with direction
A and window oset KA, we have B = XA(J) within the reject window, then
the identical trajectory will be produced by starting at B = XB(0), with direction
B = A and window oset KB = KA + J, and A = XB(J) will be in the reject
window.

We can thus prove detailed balance separately for each such trajectory. The
probability of being in a small region of volume V around A, of then picking values
for  and K that generate a particular trajectory for which a state in the region of
B is in the reject window, of then chosing to pick a state from the reject window,
and of nally chosing the state in the region of B as the next state, is as follows:

p(qA, pA) V 

1
2



1
W

 (1  a(F (A)F (R)))  exp(H(qB, pB) + F (R))

(17)

The probability of generating the same trajectory starting from the region of B, and
of then ending up in the region of A, is

p(qB, pB) V 

1
2



1
W

 (1  a(F (A)F (R)))  exp(H(qA, pA) + F (R))

(18)

These are readily seen to be equal upon substituting from equation (4).

Detailed balance for transitions to a state in the accept window follows similarly,
using the fact that the set of possible trajectories that start at state A and that
include state B in the accept window is the same as the set of trajectories that start
at B and include A in the accept window, except that in the later trajectories the
accept and reject windows are exchanged. In detail, if for the trajectory starting at
A = XA(0), with window oset KA and direction A, we have B = XA(J) within

7

the accept window, AA, while A is in the reject window, RA, then the trajectory
produced by starting at B = XB(0), with window oset KB = L  KA  J and
B = A, will lead to A = XB(J) being in the accept window, AB, while B is in
the reject window, RB. Furthermore, we will have AA = RB and RA = AB.

The probability of being in a small region of volume V around A, of then picking
values for  and K that generate a particular trajectory for which a state in the
region of B is in the accept window, of then chosing to pick a state from the accept
window, and of nally chosing the state in the region of B as the next state, is as
follows:

p(qA, pA) V 

1
2



1
W

 a(F (AA)F (RA))  exp(H(qB, pB) + F (AA))

(19)

For the probability of generating the same trajectory, but with accept and reject
windows exchanged, starting from the region of B, and of then picking a state in
the region of A, we have

p(qB, pB) V 

1
2



1
W

 a(F (AB)F (RB))  exp(H(qA, pA) + F (AB))

(20)

Again, these are seen to be equal upon substituting from equations (4) and (11),
remembering that AA = RB and RA = AB.

6 Acceptance probability for the generalized algorithm

Two situations where the use of windows will increase the acceptance probability of
the hybrid Monte Carlo algorithm are illustrated in Figure 1.

In the trajectory of Figure 1(a), the energies of the states in the reject window,
at the start of the trajectory, are all approximately equal to the energy of the current
state, H0. Most of the states in the accept window, at the end of the trajectory,
have energies in the vicinity of H+, much greater than that of the current state.
However, one state has a much lower energy, H.

If the standard hybrid Monte Carlo algorithm is applied in this situation, with
the end-point of the trajectory randomly picked from the last W states shown, the
probability of acceptance will be approximately 1/W , since moves to states with
energy H+ would almost certainly be rejected, while a move to the one state with
energy H would be accepted.

In contrast, if the generalized algorithm is applied with a window of size W , the

move will always be accepted. The free energy of the reject window will be

F (R)   log(W exp(H0))  H0  log(W )

(21)

Assuming H+  H, the free energy of the accept window will be

F (A)   log((W  1) exp(H+) + exp(H))  H

(22)

8

Thus, if H0  H > log(W ), the move will be accepted, and the particular state
chosen within the accept window will almost certainly be the one with energy H.
Note that it is essential to this example that a state in the accept window have
lower energy than those in the reject window. If this is not the case, the acceptance
probability is the same as for the standard algorithm.

The trajectory of Figure 1(b) illustrates a dierent, perhaps more typical, sit-
uation where the use of windows also increases the acceptance probability. Here,
both windows contain approximately equal numbers of low and high energy states.
Note that the current state is likely to be one of the low energy ones, since it is
Boltzmann distributed.

With the standard algorithm, the end state might equally well be one of high
energy or one of low energy. In the former case, the move would likely be rejected,
while in the later, it would have a good probability of being accepted. The total
acceptance probability will thus be around 1/2.

If the generalized algorithm is used with a window size large compared to the
time scale of energy uctuations, however, the free energy of both the accept and
reject windows will be approximately equal, and the acceptance probability will be
near one. The particular state chosen within the accept window will likely be one
with low energy.

These examples show that the use of windows can be benecial, but they do
not indicate the magnitude of the benet, nor whether there is any improvement
in the asymptotic form of the time requirements as system size increases. Indeed,
for xed values of L, 0, and W , the acceptance probability declines exponentially
with increasing system size, as for the standard algorithm. This scaling behaviour is
due to the free energies of the windows, and hence their dierence, being extensive
quantities that increase in proportion to system size.

7 Performance for a system of uncoupled oscillators

To gain some insight into the degree of benet from using the generalized algorithm,
and into its scaling behaviour, I have tested it empirically on systems of uncoupled
oscillators. These simple systems are meant to model more complex systems in which
the components are not completely independent, but interact only weakly. The
behaviour of the standard hybrid Monte Carlo algorithm for systems of uncoupled
oscillators has been analysed in detail by Kennedy and Pendleton [3].

The potential energy function for such a system is

E(q) =

1
2

NXi=1

2
i q2
i

(23)

In the Boltzmann distribution with respect to E, each qi is independent, and dis-
tributed as a Gaussian with zero mean and standard deviation 1/i. Since the

9

operation of the hybrid Monte Carlo algorithm is invariant with respect to transla-
tions and rotations of the coordinates, these systems in fact model the behaviour of
the algorithm as applied to any multivariate Gaussian distribution.

Note that for the leapfrog method to be stable, with the error in H remaining
bounded even for long trajectories, it is necessary for the step size to be less than
2/max, where max is the largest of the i. For ecient exploration of the other
coordinates, the average length of a trajectory in ctitious time, Tt, should be in
the vicinity of 1/min.

In using these systems as a test bed, we must be clear concerning which aspects
of the system we expect to carry over to realistic problems, and which will not. I
assume here that the approximate magnitudes of min and max and the general
distribution of the i are known, and that these may be used to select appropriate
values for the step size and trajectory length. I assume that their exact values would
not be known in a realistic system  indeed, they will not be precisely dened, since
the components of the real system will not be completely uncoupled. To model this,
the step size (and hence the trajectory length as well) was varied slightly at random,
in order to avoid results that depend on precise tuning of these parameters.

I will also assume that we are interested in systems for which the ratio max/min
is large. This ratio is a measure of the inherent diculty of the problem, being
(roughly) the number of leapfrog steps required to generate an independent cong-
uration. In the experiments, the length in ctitious time of a trajectory was chosen
to be large enough for the acceptance probability to have reached equilibrium. In
a real system, however, the appropriate trajectory length (Tt  1/min) might well
be much longer than this.

Since chosing any particular value for Tt would be arbitrary, I have for the most
part evaluated the algorithms on the assumption that Tt is very large. The cost
of a particular combination of window size and average step size was accordingly
taken to be

C = 1 / ((1))

(24)

where  is the probability of a move being rejected, and  is the average step size
(recall that the actual step sizes used will be slight perturbations around this aver-
age). This cost measure is proportional to the number of energy gradient evaluations
needed to generate a given number of accepted moves of average length Tt, provided
Tt is much greater than Tw, the length in ctitious time of the windows. Note that
this cost measure places no value on transitions within the reject window, though
these presumably improve sampling at least somewhat.

If Tw is comparable to Tt, then the above measure would not be appropriate,
since it ignores the eort expended in computing those portions of the trajectory
that lie before the current state and after the new state. An appropriate cost in this
case would be (1 + Tw/Tt) / ((1)).

I assume that for a given window length, Tw, and a given system size, N , the

10

value of  that minimizes C can feasibly be found, and that this minimal value of C
is thus the appropriate measure of the cost of the algorithm for a particular window
length. If the rejection probability has the functional form

 = F (g(N ) k)

(25)

then one can show by straightforward means that this minimum is reached at a
value of  that is independent of N . The scaling properties of the algorithm can
then be found by determining how  must decrease as N increases in order to keep
the rejection probability constant. Note that we are measuring cost as the number
of evaluations of the energy gradient, not the time required for these evaluations.
Computation time per evaluation will vary with system size in a manner which
depends on the application, but which will generally add an additional factor of at
least N to the total computation time as a function of system size.

I have tested the standard and the generalized algorithms on systems for which
N = 100, 200, 400, 800, 1600, and 3200. In each case, the i were selected randomly
from the range 500 to 1000, with a uniform distribution for log(). Though I assume
that components with much smaller  would also be present in a real system, such
were not actually included in the simulation, in order to save time. Their inclusion
would have had a negligible eect on the acceptance probability, since the accuracy
of the leapfrog method is very high when 1/ is much greater than the step size.

An average trajectory length of Tt = 1  1000  (1/max) was used. Several of
the simulations were done with Tt = 2 as well, and the results conrmed that the
acceptance probability had indeed reached equilibrium at Tt = 1.

For a given average step size, , and for a given window size, W , the number of
steps in the entire trajectory, L, was set so that Tt = (LW +1). (This calculation
accounts for the average number of steps before and after the current and new
states.) The trajectory was then computed with these values of L and W and with
a value of 0 randomly selected from the region within 1% of the given .

Runs were done of the standard algorithm, for which W = 1, and of the gen-
eralized algorithm with a window length of Tw = 0.20, for which the number of
states in the window was W = Tw/. Some runs with Tw = 0.05 and Tw = 0.10
were done as well, with results that were similar to but not quite as good as those
for Tw = 0.20. Values for  of . . . , 0.000707, 0.000841, 0.001000, 0.001189, . . ., in
geometric steps of 21/4 were used.
In each run, 1000 trajectories were generated
starting from position and momentum coordinates picked from the Boltzmann dis-
tribution, independently for each trajectory. The proportion of rejected moves, ,
was taken to be an estimate of the rejection probability, . The standard error for
this estimate is 0.016 at  = 0.5, declining to 0.009 at  = 0.1 or  = 0.9. An

estimate, bC, for the cost follows from equation (24).

The results are shown in Figure 2, which plots the estimated rejection probability
and consequent cost for each value of N and for various values of , for both the
standard algorithm and the generalized algorithm with Tw = 0.20. When the best

11

value of  is used in each case, the cost of the generalized algorithm is roughly
half that of the standard algorithm, with some indication that the advantage of the
generalized algorithm may be greater for the larger N . Interestingly, the rejection
probability with the optimal  is signicantly lower for the generalized algorithm
than for standard algorithm.

In analysing this data further, we can rst compare with the analytic results of
[3]. They derive the following expression for the rejection probability of the standard
algorithm applied to a system of uncoupled oscillators (adapted from their equation
(2.10)):

  erf(cid:18)qN 4/32(cid:19)

(26)

i sin2(iTt)/4. Assuming that the small random variation in ,
and hence Tt, is enough to randomize the phases in this sum, and using the fact that
1
2 , we get that, for the experiment described here, the rejection

0

where  = N 1Pi 4
2R 2

sin2(x)dx = 1
probability should be

  erf(cid:18)qN  4/256(cid:19)

(27)

where  = N 1Pi 4

i  3.38  1011. The rejection probability thus has the form
of equation (25). As system size increases,  should be scaled as N 1/4 in order to
keep the rejection probability constant, and the cost will grow as N 1/4.

In Figure 3,  is plotted against N  4 for all runs of the standard algorithm. As
expected,  appears to be a function of N  4, as the spread in the data points in
comparable to the standard error. (Note that here, and in Figure 4, the standard
error is apparently larger for smaller values of , due to the logarithmic scale.)
Comparison with the exact predictions of equation (27) (not shown in the gure)
shows a good t, except for a slight departure for large values of the rejection rate.
We can hypothesize that the rejection probability of the generalized algorithm
for a given window length will also be a function of N  4. If this is the case, the cost
for the generalized algorithm will also scale as N 1/4, though there could, as seen
above, be an improvement in the constant factor over the standard algorithm. To
test this hypothesis, Figure 3 also shows  plotted against N  4 for all runs of the
generalized algorithm with Tw = 0.20. A tendency of the curves for the larger N to
lie below those for the smaller N is apparent, leading one to reject this hypothesis.
The data for the generalized algorithm is better t by the alternative hypothesis
that the rejection probability is a function of N 7/8 4. This is seen in Figure 4.
For comparison, the data for the standard algorithm is also plotted under this
assumption, and it is clear that in this case the t is bad.

If this hypothesis is true, then the step size for the generalized algorithm should
be scaled as N 7/32 to maintain a constant rejection rate, and the cost will con-
sequently grow with system size as N 7/32, an improvement over the N 1/4 scaling

12

of the standard algorithm. This result must be regarded as tentative, however. It
seems possible that for very large N the window length, Tw, might have to increase
at some rate in order to maintain good scaling behaviour. This would ultimately
aect the cost, once Tw became comparable to Tt. Behaviour could also conceivably
depend on the exact distribution of the i. A theoretical analysis is thus needed to
gain a better understanding of the performance of the generalized algorithm. It is
clear, however, that at the very least, it can improve performance by a signicant
constant factor.

8 Variations on the algorithm

Two variations on the generalized algorithm described here are worth mentioning.
First, when a move to the accept window is rejected, it is valid to simply re-
main at the current state, rather than selecting a new state from the reject window
according to the Boltzmann probabilities. This follows from the fact that detailed
balance was shown above to hold independently for the accept and reject transitions.
Detailed balance thus continues to hold if all reject transitions are eliminated.

With this variation, the overhead of saving states is somewhat reduced. Typi-
cally, however, this overhead is small compared to the cost of evaluating the gradient
of the energy, and its elimination may not be worth giving up the additional explo-
ration provided by the reject transitions. Note that it is in any case necessary to
visit all the states in the reject window, in order to compute its free energy.

A second variation may be useful when the ideal step size is not known a priori.
In such cases, we may have to use step sizes selected at random from a fairly broad
distribution. Trajectories computed with a step size that is too large will result in
large changes in H and are unlikely to be accepted.

To save computation, we can terminate such trajectories early, stopping when-
ever a single leapfrog step changes H by an amount, positive or negative, whose
magnitude is greater than some threshold. The state reached after this large change
in H is not included. Such truncated trajectories will have smaller than normal
accept and/or reject windows, but examination of the proof of validity in Section 5
shows that they may validly be treated the same way as normal trajectories. The
accept window for a truncated trajectory may, in fact, be null, in which case the
move is rejected. (The reject window will always contain at least the current state.)
This variation is applicable to the standard hybrid Monte Carlo algorithm, where
the window size is one. In this case, all truncated trajectories are rejected, with the
current state remaining unchanged.

Acknowledgements

I thank David MacKay for helpful comments. This work was supported by the
Natural Sciences and Engineering Research Council of Canada, and by the Ontario

13

Information Technology Research Centre.

14

