Abstract

This paper addresses the problem of choosing a kernel suitable for estimation with a support
vector machine, hence further automating machine learning. This goal is achieved by dening
a reproducing kernel Hilbert space on the space of kernels itself. Such a formulation leads to a
statistical estimation problem similar to the problem of minimizing a regularized risk functional.

We state the equivalent representer theorem for the choice of kernels and present a semidenite
programming formulation of the resulting optimization problem. Several recipes for constructing
hyperkernels are provided, as well as the details of common machine learning problems. Experi-
mental results for classication, regression and novelty detection on UCI data show the feasibility
of our approach.
Keywords: learning the kernel, capacity control, kernel methods, support vector machines, repre-
senter theorem, semidenite programming

1. Introduction

Kernel methods have been highly successful in solving various problems in machine learning. The
algorithms work by implicitly mapping the inputs into a feature space, and nding a suitable hy-
pothesis in this new space. In the case of the support vector machine (SVM), this solution is the
hyperplane which maximizes the margin in the feature space. The feature mapping in question is
dened by a kernel function, which allows us to compute dot products in feature space using only
objects in the input space. For an introduction to SVMs and kernel methods, the reader is referred
to numerous tutorials such as Burges (1998) and books such as Scholkopf and Smola (2002).

Choosing a suitable kernel function, and therefore a feature mapping, is imperative to the suc-
cess of this inference process. This paper provides an inference framework for learning the kernel
from training data using an approach akin to the regularized quality functional.

. This work was done when the author was at the Australian National University.

c(cid:13)2005 Cheng Soon Ong, Alexander J. Smola and Robert C. Williamson.

ONG, SMOLA AND WILLIAMSON

1.1 Motivation

As motivation for the need for methods to learn the kernel, consider Figure 1, which shows the sep-
arating hyperplane, the margin and the training data for a synthetic data set. Figure 1(a) shows the
classication function for a support vector machine using a Gaussian radial basis function (RBF)
kernel. The data has been generated using two Gaussian distributions with standard deviation 1
in one dimension and 1000 in the other. This difference in scale creates problems for the Gaus-
sian RBF kernel, since it is unable to nd a kernel width suitable for both directions. Hence, the
classication function is dominated by the dimension with large variance. Increasing the value of
the regularization parameter, C, and hence decreasing the smoothness of the function results in a
hyperplane which is more complex, and equally unsatisfactory (Figure 1(b)). The traditional way
to handle such data is to normalize each dimension independently.

Instead of normalising the input data, we make the kernel adaptive to allow independent scales
for each dimension. This allows the kernel to handle unnormalised data. However, the resulting
kernel would be difcult to hand-tune as there may be numerous free variables. In this case, we
have a free parameter for each dimension of the input. We learn this kernel by dening a quantity
analogous to the risk functional, called the quality functional, which measures the badness of the
kernel function. The classication function for the above mentioned data is shown in Figure 1(c).
Observe that it captures the scale of each dimension independently. In general, the solution does not
consist of only a single kernel but a linear combination of them.

5

4

3

2

1

0

1

i

n
o
i
s
n
e
m
d
e
c
n
a
i
r
a
v




l
l

a
m
S

5

4

3

2

1

0

1

5

4

3

2

1

0

1

i

n
o
i
s
n
e
m
d
e
c
n
a
i
r
a
v




l
l

a
m
S

i

n
o
i
s
n
e
m
d
e
c
n
a
i
r
a
v




l
l

a
m
S

3000 2000 1000

0

1000

2000

3000

4000

5000

6000

Large variance dimension

3000 2000 1000

0

1000

2000

3000

4000

5000

6000

3000 2000 1000

0

1000

2000

3000

4000

5000

6000

Large variance dimension

Large variance dimension

(b) Standard Gaussian RBF kernel
(C=108)

(a) Standard Gaussian RBF kernel
(C=10)
Figure 1: For data with highly non-isotropic variance, choosing one scale for all dimensions leads
to unsatisfactory results. Plot of synthetic data, showing the separating hyperplane and
the margins given for a uniformly chosen length scale (left and middle) and an automatic
width selection (right).

(c) RBF-Hyperkernel with adaptive
widths

1.2 Related Work

We analyze some recent approaches to learning the kernel by looking at the objective function that
is being optimized and the class of kernels being considered. We will see later (Section 2) that this
objective function is related to our denition of a quality functional. Cross validation has been used
to select the parameters of the kernels and SVMs (Duan et al., 2003, Meyer et al., 2003), with vary-
ing degrees of success. The objective function is the cross validation risk, and the class of kernels
is a nite subset of the possible parameter settings. Duan et al. (2003) and Chapelle et al. (2002)

1044

HYPERKERNELS

test various simple approximations which bound the leave one out error, or some measure of the
capacity of the SVM. The notion of Kernel Target Alignment (Cristianini et al., 2002) uses the ob-
jective function tr(Kyy) where y are the training labels, and K is from the class of kernels spanned
by the eigenvectors of the kernel matrix of the combined training and test data. The semidenite
programming (SDP) approach (Lanckriet et al., 2004) uses a more general class of kernels, namely
a linear combination of positive semidenite matrices. They minimize the margin of the resulting
SVM using a SDP for kernel matrices with constant trace. Similar to this, Bousquet and Herrmann
(2002) further restricts the class of kernels to the convex hull of the kernel matrices normalized by
their trace. This restriction, along with minimization of the complexity class of the kernel, allows
them to perform gradient descent to nd the optimum kernel. Using the idea of boosting, Crammer
et al. (2002) optimize (cid:229)
t are the weights used in the boosting algorithm. The class
of base kernels {Kt} is obtained from the normalized solution of the generalized eigenvector prob-
lem. In principle, one can learn the kernel using Bayesian methods by dening a suitable prior, and
learning the hyperparameters by optimizing the marginal likelihood (Williams and Barber, 1998,
Williams and Rasmussen, 1996). As an example of this, when other information is available, an
auxiliary matrix can be used with the EM algorithm for learning the kernel (Tsuda et al., 2003).
Table 1 summarizes these approaches. The notation K (cid:23) 0 means that K is positive semidenite,
that is for all a  Rn, aKa > 0.

tKt, where b

t b

Kernel class (K )

Finite set of kernels

Approach
Cross Validation
Alignment
SDP
Complexity Bound
Boosting
Bayesian
EM Algorithm

Objective
CV Risk

yKy
margin
margin

Exp/LogLoss
neg. log-post.
KL Divergence

i=1

{(cid:229) m
{(cid:229) m

i=1

ivivi such that vi are eigenvectors of K}
{(cid:229) m
iKi such that Ki (cid:23) 0,trKi = c,b
i > 0}

iKi such that Ki (cid:23) 0,trKi = c}

i=1

Base kernels from generalized eigenvector problem

dependent on prior

linear combination of auxiliary matrix

Table 1: Summary of recent approaches to kernel learning.

1.3 Outline of the Paper

The contribution of this paper is a theoretical framework for learning the kernel. Using this frame-
work, we analyze the regularized risk functional. Motivated by the ideas of Cristianini et al. (2003),
we show (Section 2) that for most kernel-based learning methods there exists a functional, the qual-
ity functional, which plays a similar role to the empirical risk functional. We introduce a kernel
on the space of kernels itself, a hyperkernel (Section 3), and its regularization on the associated
hyper reproducing kernel Hilbert space (Hyper-RKHS). This leads to a systematic way of parame-
terizing kernel classes while managing overtting (Ong et al., 2002). We give several examples of
hyperkernels and recipes to construct others (Section 4). Using this general framework, we consider
the specic example of using the regularized risk functional in the rest of the paper. The positive
deniteness of the kernel function is ensured using the positive deniteness of the kernel matrix
(Section 5), and the resulting optimization problem is a semidenite program. The semidenite
programming approach follows that of Lanckriet et al. (2004), with a different constraint due to a

1045

b
b
b
ONG, SMOLA AND WILLIAMSON

difference in regularization (Ong and Smola, 2003). Details of the specic optimization problems
associated with the C-SVM, n -SVM, Lagrangian SVM, n -SVR and one class SVM are dened in
Section 6. Experimental results for classication, regression and novelty detection (Section 7) are
shown. Finally some issues and open problems are discussed (Section 8).

2. Kernel Quality Functionals

We denote by X the space of input data and Y the space of labels (if we have a supervised learning
problem). Denote by Xtrain := {x1, . . . , xm} the training data and with Ytrain := {y1, . . . , ym} a set of
corresponding labels, jointly drawn independently and identically from some probability distribu-
tion Pr(x, y) on X  Y . We shall, by convenient abuse of notation, generally denote Ytrain by the
vector y, when writing equations in matrix notation. We denote by K the kernel matrix given by
Ki j := k(xi, x j) where xi, x j  Xtrain and k is a positive semidenite kernel function. We also use trK
to mean the trace of the matrix and |K| to mean the determinant.
We begin by introducing a new class of functionals Q on data which we will call quality func-
tionals. Note that by quality we actually mean badness or lack of quality, as we would like to
minimize this quantity. Their purpose is to indicate, given a kernel k and the training data, how
suitable the kernel is for explaining the training data, or in other words, the quality of the kernel for
the estimation problem at hand. Such quality functionals may be the Kernel Target Alignment, the
negative log posterior, the minimum of the regularized risk functional, or any luckiness function for
kernel methods. We will discuss those functionals after a formal denition of the quality functional
itself.

2.1 Empirical and Expected Quality

Denition 1 (Empirical Quality Functional) Given a kernel k, and data X,Y , we dene Qemp(k, X,Y )
to be an empirical quality functional if it depends on k only via k(xi, x j) where xi, x j  X for
1 6 i, j 6 m.

By this denition, Qemp is a function which tells us how well matched k is to a specic data set X,Y .
Typically such a quantity is used to adapt k in such a manner that Qemp is optimal (for example,
optimal Kernel Target Alignment, greatest luckiness, smallest negative log-posterior), based on this
one single data set X,Y . Provided a sufciently rich class of kernels K it is in general possible to
nd a kernel k  K that attains the minimum of any such Qemp regardless of the data. However,
it is very unlikely that Qemp(k, X,Y ) would be similarly small for other X,Y , for such a k. To
measure the overall quality of k we therefore introduce the following denition:

Denition 2 (Expected Quality Functional) Denote by Qemp(k, X,Y ) an empirical quality func-
tional, then

is dened to be the expected quality functional. Here the expectation is taken over X,Y , where all
xi, yi are drawn from Pr(x, y).

Q(k) := EX,Y(cid:2)Qemp(k, X,Y )(cid:3)

Observe the similarity between the empirical quality functional, Qemp(k, X,Y ), and the empirical
risk of an estimator, Remp( f , X,Y ) = 1
i=1 l(xi, yi, f (xi)) (where l is a suitable loss function); in
m

(cid:229) m

1046

HYPERKERNELS

both cases we compute the value of a functional which depends on some sample X,Y drawn from
Pr(x, y) and a function and in both cases we have

Q(k) = EX,Y(cid:2)Qemp(k, X,Y )(cid:3) and R( f ) = EX,Y(cid:2)Remp( f , X,Y )(cid:3) .

Here R( f ) denotes the expected risk. However, while in the case of the empirical risk we can
interpret Remp as the empirical estimate of the expected loss R( f ) = Ex,y[l(x, y, f (x))], due to the
general form of Qemp, no such analogy is available for quality functionals. Finding a general-
purpose bound of the expected error in terms of Q(k) is difcult, since the denition of Q depends
heavily on the algorithm under consideration. Nonetheless, it provides a general framework within
which such bounds can be derived.

To obtain a generalization error bound, it is sufcient that Qemp is concentrated around its
expected value. Furthermore, one would require the deviation of the empirical risk to be upper
bounded by Qemp and possibly other terms. In other words, we assume a) we have given a concen-
tration inequality on quality functionals, such as

and b) we have a bound on the deviation of the empirical risk in terms of the quality functional

Then we can chain both inequalities together to obtain the following bound

Pr(cid:8)|Qemp(k, X,Y ) Q(k)| > e Q(cid:9) < d Q,
Pr(cid:8)|Remp( f , X,Y ) R( f )| > e R(cid:9) < d (Qemp).
Pr(cid:8)|Remp( f , X,Y ) R( f )| > e R(cid:9) < d Q + d (Q + e Q).

This means that the bound now becomes independent of the particular value of the quality func-
tional obtained on the data, rather than the expected value of the quality functional. Bounds of this
type have been derived for Kernel Target Alignment (Cristianini et al., 2003, Theorem 9) and the
Algorithmic Luckiness framework (Herbrich and Williamson, 2002, Theorem 17).

2.2 Examples of Qemp
Before we continue with the derivations of a regularized quality functional and introduce a cor-
responding reproducing kernel Hilbert space, we give some examples of quality functionals and
present their exact minimizers, whenever possible. This demonstrates that given a rich enough fea-
ture space, we can arbitrarily minimize the empirical quality functional Qemp. The difference here
from traditional kernel methods is the fact that we allow the kernel to change. This extra degree of
freedom allows us to overt the training data. In many of the examples below, we show that given a
feature mapping which can model the labels of the training data precisely, overtting occurs. That
is, if we use the training labels as the kernel matrix, we arbitrarily minimize the quality functional.
The reader who is convinced that one can arbitrarily minimize Qemp, by optimizing over a suitably
large class of kernels, may skip the following examples.

Example 1 (Regularized Risk Functional) These are commonly used in SVMs and related kernel
methods (see Wahba (1990), Vapnik (1995), Scholkopf and Smola (2002)). They take on the general
form

Rreg( f , Xtrain,Ytrain) :=

l(xi, yi, f (xi)) +

2k fk2

H

(1)

m(cid:229)

i=1

1
m

1047

l
ONG, SMOLA AND WILLIAMSON

where k fk2
H is the RKHS norm of f and l is a loss function such that for f (xi) = yi, l(xi, yi, yi) = 0.
By virtue of the representer theorem (see Section 3) we know that the minimizer of (1) can be written
as a kernel expansion. This leads to the following denition of a quality functional, for a particular
loss functional l:

Qregrisk

emp

(k, Xtrain,Ytrain) := min

a Rm" 1

m

l(xi, yi, [Ka

]i) +

m(cid:229)

i=1

a Ka # .

2

(2)

. However, we know that Qregrisk

The minimizer of (2) is somewhat difcult to nd, since we have to carry out a double minimization
over K and a
is bounded from below by 0. Hence, it is sufcient if
we can nd a (possibly) suboptimal pair (a
 Note that for K = b yy and a = 1
l(xi, yi, f (xi)) = 0 and therefore Qregrisk
make Qregrisk

, k) for which Qregrisk
b kyk2 y we have Ka = y and a Ka = b 1. This leads to
. For sufciently large b we can

(k, Xtrain,Ytrain) arbitrarily close to 0.

for any e > 0:

(k, Xtrain,Ytrain) =

emp  e

emp

emp

emp

2b

 Even if we disallow setting K arbitrarily close to zero by setting trK = 1, nding the minimum
kzk2 zz, where z  Rm, and a = z. Then Ka = z

of (2) can be achieved as follows: let K = 1
and we obtain

1
m

m(cid:229)

i=1

l(xi, yi, [Ka

a Ka =

]i) +

2

m(cid:229)

i=1

l(xi, yi, zi) +

2kzk2
2.

(3)

Choosing each zi = argminz l(xi, yi,z (xi))+
z 2, where z are the possible hypothesis functions
obtained from the training data, yields the minimum with respect to z. Since (3) tends to zero
and the regularized risk is lower bounded by zero, we can still arbitrarily minimize Qregrisk
.
This is not surprising since the set of allowable K is huge.

emp

2

Example 2 (Cross Validation) Cross validation is a widely used method for estimating the gener-
alization error of a particular learning algorithm. Specically, the leave-one-out cross validation is
an almost unbiased estimate of the generalization error (Luntz and Brailovsky, 1969). The quality
functional for classication using kernel methods is given by:

Qloo

emp(k, Xtrain,Ytrain) := min

a Rm" 1

m

m(cid:229)
i=1yi sign([Ka

i]i)# ,

which is optimized in Duan et al. (2003), Meyer et al. (2003).

Choosing K = yy and a

i and yi are the vectors a and y with the ith element
set to zero, we have Ka
i = yi. Hence we can match the training data perfectly. For a validation set of
larger size, i.e. k-fold cross validation, the same result can be achieved by dening a corresponding

kyik2 yi, where a

i = 1

.

Example 3 (Kernel Target Alignment) This quality functional was introduced by Cristianini et al.
(2002) to assess the alignment of a kernel with training labels. It is dened by

Qalignment

emp

(k, Xtrain,Ytrain) := 1

tr(Kyy)
kyk2
2kKkF

.

1048

(4)

l
l
l
l
l
a
HYPERKERNELS

Here kyk2 denotes the 2 norm of the vector of observations and kKkF is the Frobenius norm, i.e.,
i, j(Ki j)2. This quality functional was optimized in Lanckriet et al. (2004). By
kKk2
decomposing K into its eigensystem one can see that (4) is minimized, if K = yy, in which case

F := tr(KK) = (cid:229)

Qalignment

emp

(k, Xtrain,Ytrain) = 1

tr(yyyy)
kyk2
2kyykF

= 1 kyk4
kyk2
2kyk2

2

= 0.

2

We cannot expect that Qalignment
(k, X,Y ) = 0 for data other than that chosen to determine k, in
other words, a restriction of the class of kernels is required. This was also observed in Cristianini
et al. (2003).

emp

The above examples illustrate how existing methods for assessing the quality of a kernel t
within the quality functional framework. We also saw that given a rich enough class of kernels K ,
optimization of Qemp over K would result in a kernel that would be useless for prediction purposes,
in the sense that they can be made to look arbitrarily good in terms of Qemp but with the result that
the generalization performance will be poor. This is yet another example of the danger of optimizing
too much and overtting  there is (still) no free lunch.

3. Hyper Reproducing Kernel Hilbert Spaces

We now propose a conceptually simple method to optimize quality functionals over classes of ker-
nels by introducing a reproducing kernel Hilbert space on the kernel k itself, so to say, a Hyper-
RKHS. We rst review the denition of a RKHS (Aronszajn, 1950).

Denition 3 (Reproducing Kernel Hilbert Space) Let X be a nonempty set (the index set) and
denote by H a Hilbert space of functions f : X  R. H is called a reproducing kernel Hilbert
space endowed with the dot product h,i (and the norm k fk :=ph f , fi) if there exists a function
k : X  X  R with the following properties.

1. k has the reproducing property

h f , k(x,)i = f (x) for all f  H , x  X ;

in particular, hk(x,), k(x,)i = k(x, x) for all x, x  X .

2. k spans H , i.e. H = span{k(x,)|x  X } where X is the completion of the set X.

In the rest of the paper, we use the notation k to represent the kernel function and H to represent
the RKHS. In essence, H is a Hilbert space of functions, which has the special property of being
generated by the kernel function k.

The advantage of optimization in an RKHS is that under certain conditions the optimal solutions
can be found as the linear combination of a nite number of basis functions, regardless of the
dimensionality of the space H the optimization is carried out in. The theorem below formalizes this
notion (see Kimeldorf and Wahba (1971), Cox and OSullivan (1990)).
Theorem 4 (Representer Theorem) Denote by W
: [0, )  R a strictly monotonic increasing
function, by X a set, and by l : (X  R2)m  R{ } an arbitrary loss function. Then each mini-
mizer f  H of the general regularized risk

l ((x1, y1, f (x1)) , . . . , (xm, ym, f (xm))) + W

(k fkH )

1049

ONG, SMOLA AND WILLIAMSON

admits a representation of the form

where a

i  R for all 1 6 i 6 m.

3.1 Regularized Quality Functional

f (x) =

m(cid:229)

i=1

ik(xi, x),

(5)

To learn the kernel, we need to dene a function space of kernels, a method to regularize them and
a practical optimization procedure. We will address each of these issues in the following. We dene
an RKHS on kernels k : X  X  R, simply by introducing the compounded index set, X := X  X
and by treating k as a function k : X  R:
Denition 5 (Hyper Reproducing Kernel Hilbert Space) Let X be a nonempty set. and denote
by X := X  X the compounded index set. The Hilbert space H of functions k : X  R, endowed
with a dot product h,i (and the norm kkk =phk, ki) is called a hyper reproducing kernel Hilbert
space if there exists a hyperkernel k : X  X  R with the following properties:
1. k has the reproducing property hk, k(x,)i = k(x) for all k  H ; in particular, hk(x,), k(x,)i =

k(x, x).

2. k spans H , i.e. H = span{k(x,)|x  X }.
3. k(x, y, s,t) = k(y, x, s,t) for all x, y, s,t  X .
This is a RKHS with the additional requirement of symmetry in its rst two arguments (in fact,
we can have a recursive denition of an RKHS of an RKHS ad innitum, with suitable restric-
tions on the elements). We dene the corresponding notations for elements, kernels, and RKHS by
underlining it. What distinguishes H from a normal RKHS is the particular form of its index set
(X = X 2) and the additional condition on k to be symmetric in its rst two arguments, and therefore
in its second two arguments as well.

This approach of dening a RKHS on the space of symmetric functions of two variables leads us
to a natural regularization method. By analogy with the denition of the regularized risk functional
(1), we proceed to dene the regularized quality functional.

Denition 6 (Regularized Quality Functional) Let X,Y be the combined training and test set of
examples and labels respectively. For a positive semidenite kernel matrix K on X, the regularized
quality functional is dened as

Qreg(k, X,Y ) := Qemp(k, X,Y ) +

l Q
2 kkk2
H ,

(6)

where l Q > 0 is a regularization constant and kkk2

H denotes the RKHS norm in H .

Note that although we have possibly non positive kernels in H , we dene the regularized quality
functional only on positive semidenite kernel matrices. This is a slightly weaker condition than
requiring a positive semidenite kernel k, since we only require positivity on the data. Since Qemp
depends on k only via the data, this is sufcient for the above denition. Minimization of Qreg is

1050

a
HYPERKERNELS

H effectively
less prone to overtting than minimizing Qemp, since the regularization term
controls the complexity of the class of kernels under consideration. Bousquet and Herrmann (2002)
provide a generalization error bound by estimating the Rademacher complexity of the kernel classes
in the transduction setting. Regularizers other than kkk2
H are possible, such as p penalties. In this
paper, we restrict ourselves to the 2 norm (6). The advantage of (6) is that its minimizer satises
the representer theorem.

l Q
2 kkk2

Lemma 7 (Representer Theorem for Hyper-RKHS) Let X be a set, Qemp an arbitrary empirical
quality functional, and X,Y the combined training and test set, then each minimizer k  H of the
regularized quality functional Qreg(k, X,Y ) admits a representation of the form

k(x, x) =

m(cid:229)

i, j

i jk((xi, x j), (x, x)) for all x, x  X,

(7)

where b

i j  R, for each 1 6 i, j 6 m.

H is an RKHS regularizer, so the representer theorem applies and (7) follows.

Proof All we need to do is rewrite (6) so that it satises the conditions of Theorem 4. Let xi j :=
(xi, x j). Then Qemp(k, X,Y ) has the properties of a loss function, as it only depends on k via its values
at xi j. Note too that the kernel matrix K also only depends on k via its values at xi j. Furthermore,
l Q
2 kkk2
Lemma 7 implies that the solution of the regularized quality functional is a linear combination of
hyperkernels on the input data. This shows that even though the optimization takes place over an
entire Hilbert space of kernels, one can nd the optimal solution by choosing among a nite number.
Note that the minimizer (7) is not necessarily positive semidenite. In practice, this is not what
we want, since we require a positive semidenite kernel but we do not have any guarantees for
examples in the test set. Therefore we need to impose additional constraints of the type K (cid:23) 0 or
k is a Mercer Kernel. While the latter is almost impossible to enforce directly, the former could be
veried directly, hence imposing a constraint only on the values of the kernel matrix k(xi, x j) rather
than on the kernel function k itself. This means that the conditions of the Representer Theorem
apply and (7) applies (with suitable constraints on the coefcients b

i j).

Another option is to be somewhat more restrictive and require that all expansion coefcients
i, j > 0 and all the functions be positive semidenite kernels. This latter requirement can be for-
mally stated as follows: For any xed x  X the hyperkernel k is a kernel in its second argument; that
is for any xed x  X , the function k(x, x) := k(x, (x, x)), with x, x  X , is a positive semidenite
kernel.

Proposition 8 Given a hyperkernel, k with elements such that for any xed x  X , the function
k(xp, xq) := k(x, (xp, xq)), with xp, xq  X , is a positive semidenite kernel, and b
i j > 0 for all i, j =
1, . . . , m, then the kernel

k(xp, xq) :=

i jk(xi, x j, xp, xq)

m(cid:229)

is positive semidenite.

i, j=1

Proof The result is obtained by observing that positive combinations of positive semidenite ker-
nels are positive semidenite.

1051

b
b
b
ONG, SMOLA AND WILLIAMSON

While this may prevent us from obtaining the minimizer of the objective function, it yields a
much more amenable optimization problem in practice, in particular if the resulting cone spans a
large enough space (as happens with increasing m). In the subsequent derivations of optimization
problems, we choose this restriction as it provides a more tractable problem in practice. In Section 4,
we give examples and recipes for constructing hyperkernels. Before that, we relate our framework
dened above to Bayesian inference.

3.2 A Bayesian Perspective

A generative Bayesian approach to inference encodes all knowledge we might have about the prob-
lem setting into a prior distribution. Hence, the choice of the prior distribution determines the
behaviour of the inference, as once we have the data, we condition on the prior distribution we have
chosen to obtain the posterior, and then marginalize to obtain the label that we are interested in. One
popular choice of prior is the normal distribution, resulting in a Gaussian process (GP). All prior
knowledge we have about the problem is then encoded in the covariance of the GP. There exists a
GP analog to the support vector machine (for example Opper and Winther (2000), Seeger (1999)),
which is essentially obtained (ignoring normalizing terms) by exponentiating the regularized risk
functional used in SVMs.

In this section, we derive the prior and hyperprior implied by our framework of hyperkernels.
This is obtained by exponentiating Qreg, again ignoring normalization terms. Given the regularized
quality functional (Equation 6), with the Qemp set to the SVM with squared loss, we obtain the
following equation.

Qreg(k, X,Y ) :=

1
m

m(cid:229)

i=1

(yi  f (xi))2 +

2k fk2

H +

l Q
2 kkk2
H .

Exponentiating the negative of the above equation gives,

exp(Qreg(k, X,Y )) =
exp 

(yi  f (xi))2!exp(cid:18)

1
m

m(cid:229)

i=1

2k fk2

H (cid:19)exp(cid:18)

l Q
2 kkk2

H (cid:19) .

(8)

We compare Equation (8) to Gaussian process estimation. The general scheme is known in
Bayesian estimation as hyperpriors (Bishop, 1995, Chapter 10), which determine the distribution of
the priors (here the GP with covariance k). Figure 2 describes the model of an ordinary GP, where f
is drawn from a Gaussian distribution with covariance matrix K and y is conditionally independent
given f . For hyperprior estimation, we draw the prior K from a distribution instead of setting it.

Gaussian Process

?>=<
89:;?

k chosen by user

/ ?>=<
89:;K

89:;f
/?>=<

89:;y
/?>=<

Figure 2: Generative model for Gaussian process estimation

1052

l
l
/
/
/
HYPERKERNELS

To determine the distribution from which we draw the prior, we compute the hyperprior explic-

itly. For given data Z = {X,Y} and applying Bayes Rule, the posterior is given by

p( f|Z, k) =

p(Z| f , k)p( f|k)p(k)

p(k|Z)p(Z)

.

(9)

We have the directed graphical model shown in Figure 3 for a Hyperkernel-GP, where we as-
sume that the covariance matrix of the Gaussian process K is drawn according to a distribution
before performing further steps of dependency calculation. We shall now explicitly compute the
terms in the numerator of Equation (9).

Hyperkernel GP

k0, k
ONML
HIJK

p(k|k0, k)

/?>=<
89:;k

p( f|k)

89:;f
/?>=<

p(y| f , x)

89:;y
/?>=<

Figure 3: Generative model for Gaussian process estimation using hyperpriors on k dened by k.

In the following derivations, we assume that we are dealing with nite dimensional objects, to
simplify the calculations of the normalizing constants in the expressions for the distributions. Given

that we have additive Gaussian noise, that is e  N (0, 1

e I), then,

Therefore, for the whole data set (assumed to be i.i.d.),

2

p(y| f , x) (cid:181)

exp(cid:16)
p(yi| f , xi) =(cid:18)2p
e (cid:19) m

2

(y f (x))2(cid:17) .
exp 
m(cid:229)

2

i=1

(yi  f (xi))2! .

p(Y| f , X) =

m(cid:213)

i=1

We assume a Gaussian prior on the function f , with covariance function k. The positive semidenite
function, k, denes an inner product h,iH k in the RKHS denoted by H k. Then,

where F is the dimension of f and g

p( f|k) =(cid:18)2p

2

f (cid:19) F

f is a constant.

exp(cid:16)

f

2 h f , fiH k(cid:17)

We assume a Wishart distribution (Lauritzen, 1996, Appendix C), with p degrees of freedom
and covariance k0, for the prior distribution of the covariance function k, that is k  W m(p, k0). This
is a hyperprior used in the Gaussian process literature:

exp(cid:0) 1
G m(p)|k|
where G m(p) denotes the Gamma distribution, G m(p) = 2 pm
(cid:213) m
i=1
tails of the Wishart distribution, the reader is referred to Lauritzen (1996).

p(k|k0) = |k|

2tr(kk0)(cid:1)

2 p m(m1)

p
2

2

4

p(m+1)

G (cid:16) pi+1

2 (cid:17). For more de-

Observe that tr(kk0) is an inner product between two matrices. We can dene a general inner

product between two matrices, as the inner product dened in the RKHS denoted by H :

p(k|k0, k) = |k|

p(m+1)

2

exp(cid:0) 1
G m(p)|k|

2hk, k0iH(cid:1)

p
2

.

1053

/
/
/
g
g
e
g
g
e
g
g
ONG, SMOLA AND WILLIAMSON

We can interpret the above equation as measuring the similarity between the covariance matrix
that we obtain from data and the expected covariance matrix (given by the user). This similarity
is measured by a dot product dened by k. Substituting the expressions for p(Y|X, f ), p( f|k) and
p(k|k0, k) into the posterior (Equation 9), we get Equation (10) which is of the same form as the
exponentiated negative quality (Equation 8):

exp 

2

m(cid:229)

i=1

(yi  f (xi))2!exp(cid:16)

f

2 h f , fiH k(cid:17)exp(cid:18)

1

2hk, k0iH (cid:19) .

(10)

In a nutshell, we assume that the covariance function of the GP k, is distributed according to a
Wishart distribution. In other words, we have two nested processes, a Gaussian and a Wishart pro-
cess, to model the data generation scheme. Hence we are studying a mixture of Gaussian processes.
Note that the maximum likelihood (ML-II) estimator (MacKay, 1994, Williams and Barber, 1998,
Williams and Rasmussen, 1996) in Bayesian estimation leads to the same optimization problems as
those arising from minimizing the regularized quality functional.

4. Hyperkernels

Having introduced the theoretical basis of the Hyper-RKHS, it is natural to ask whether hyperker-
nels, k, exist which satisfy the conditions of Denition 5. We address this question by giving a set
of general recipes for building such kernels.

4.1 Power Series Construction
Suppose k is a kernel such that k(x, x)  0 for all x, x  X , and suppose g : R  R is a function
with positive Taylor expansion coefcients, that is g(x ) = (cid:229)
i for basis functions x , ci > 0 for
all i = 0, . . . ,

, and convergence radius R. Then for pointwise positive k(x, x)  R,

i=0 cix

k(x, x) := g(k(x)k(x)) =

ci(k(x)k(x))i

(11)

i=0

is a hyperkernel. For k to be a hyperkernel, we need to check that rst, k is a kernel, and second,
for any xed pair of elements of the input data, x, the function k(x, (x, x)) is a kernel, and third
that is satises the symmetry condition. Here, the symmetry condition follows from the symmetry
of k. To see this, observe that for any xed x, k(x, (x, x)) is a sum of kernel functions, hence it
is a kernel itself (since kp(x, x) is a kernel if k is, for p  N). To show that k is a kernel, note
that k(x, x) = hF (x),F (x)i, where F (x) := (c0,c1k1(x),c2k2(x), . . .). Note that we require
pointwise positivity, so that the coefcients of the sum in Equation (11) are always positive. The
Gaussian RBF kernel satises this condition, but polynomial kernels of odd degree are not always
pointwise positive. In the following example, we use the Gaussian kernel to construct a hyperkernel.

Example 4 (Harmonic Hyperkernel) Suppose k is a kernel with range [0,1], (RBF kernels satisfy
this property), and set ci := (1 l h)l

i

k(x, x) = (1 l h)

.

(12)

h, i  N, for some 0 < l h < 1. Then we have
i=0(cid:0)l hk(x)k(x)(cid:1)i

1 l hk(x)k(x)

1 l h

=

1054

g
e
g


(cid:229)

(cid:229)
HYPERKERNELS

For k(x, x) = exp(s 2kx xk2) this construction leads to

1 l h

k((x, x), (x, x)) =

1 l h exp (s 2(kx xk2 +kx  xk2))

.

(13)

As one can see, for l h  1, k converges to d x,x, and thus kkk2
k on X  X.
It is straightforward to nd other hyperkernels of this sort, simply by consulting tables on power
series of functions. Table 2 contains a short list of suitable expansions.

H converges to the Frobenius norm of

g(x )
expx
sinhx
coshx
arctanhx
ln(1 x )

x 2 + 1
3!

x 3 + . . . + 1
n!
x 5 + . . . + 1

x n + . . .
x (2n+1) + . . .

(2n+1)!

x (2n) + . . .

x + 1
2!

Power series expansion
1 + 1
1!
x + 1
1
1!
3!
x 2 + 1
1 + 1
4!
2!
x 5
x 3
5 + . . . +
3 +
x 2
x 3
2 +
3 + . . . +

x 3 + 1
5!
x 4 + . . . + 1
(2n)!

x 2n+1
2n+1 + . . .
x n
n + . . .

1 +
1 +

Radius of Convergence

1

1

Table 2: Hyperkernels by Power Series Construction.

However, if we want the kernel to adapt automatically to different widths for each dimension,
we need to perform the summation that led to (12) for each dimension in its arguments sepa-
rately. Such a hyperkernel corresponds to ideas developed in automatic relevance determination
(ARD) (MacKay, 1994, Neal, 1996).

Example 5 (Hyperkernel for ARD) Let kS (x, x) = exp(dS (x, x)), where dS (x, x) = (xx)S (x
x), and S
j j separately
to obtain

is a diagonal covariance matrix. Take sums over each diagonal entry s

j = S

k((x, x), (x, x)) = (1 l h)

d(cid:229)

j=1

i=0(cid:0)l hkS (x, x)kS (x, x)(cid:1)i

=

d(cid:213)

j=1

1 l h exp(cid:16)s

1 l h
j((x j  xj)2 + (xj  xj )2)(cid:17)

.

(14)

Eq. (14) holds since k(x) factorizes into its coordinates. A similar denition also allows us to use a
distance metric d(x, x) which is a generalized radial distance as dened by Haussler (1999).

4.2 Hyperkernels Invariant to Translation

Another approach to constructing hyperkernels is via an extension of a result due to Smola et al.
(1998) concerning the Fourier transform of translation invariant kernels.
Theorem 9 (Translation Invariant Hyperkernel) Suppose k((x1x1), (x2x2)) is a function which
depends on its arguments only via x1  x1 and x2  x2. Let F 1k(w
, (x2  x2)) denote the Fourier
transform with respect to (x1  x1).

1055




x
x

(cid:229)
ONG, SMOLA AND WILLIAMSON

The function k is a hyperkernel if k(t ,t

) is a kernel in t ,t

 and F 1k(w

.

x) and w
Proof From (Smola et al., 1998) we know that for k to be a kernel in one of its arguments, its
Fourier transform has to be nonnegative. This yields the second condition. Next, we need to show
that k is a kernel in its own right. Mercers condition requires that for arbitrary f the following is
positive:

, (xx)) 0 for all (x

R f (x1, x1) f (x2, x2)k((x1  x1), (x2  x2))dx1dx1dx2dx2

R f (t 1 + x1, x1) f (t 2 + x2, x2)dx1,2k(t 1,t 2)dt 1dt 2

R g(t 1)g(t 2)k(t 1,t 2)dt 1dt 2,

=

=

where t 1 = x1  x1 and t 2 = x2  x2. Here g is obtained by integration over x1 and x2 respectively.

The latter is exactly Mercers condition on k, when viewed as a function of two variables only.

This means that we can check whether a radial basis function (for example Gaussian RBF, exponen-
tial RBF, damped harmonic oscillator, generalized Bn spline), can be used to construct a hyperkernel
by checking whether its Fourier transform is positive.

4.3 Explicit Expansion

If we have a nite set of kernels that we want to choose from, we can generate a hyperkernel which
is a nite sum of possible kernel functions. This setting is similar to that of Lanckriet et al. (2004).
Suppose ki(x, x) is a kernel for each i = 1, . . . , n (for example the RBF kernel or the polynomial

kernel), then

k(x, x) :=

n(cid:229)

i=1

ciki(x)ki(x), ki(x) > 0,x

(15)

is a hyperkernel, as can be seen by an argument similar to that of section 4.1. k is a kernel since

k(x, x) = hF (x),F (x)i, where F (x) := (c1k1(x),c2k2(x), . . . ,cnkn(x)).
Example 6 (Polynomial and RBF combination) Let k1(x, x) = (hx, xi + b)2p for some choice of
b  R+ and p  N, and k2(x, x) = exp(s 2kx xk2). Then,

k((x1, x1), (x2, x2)) = c1(hx1, x1i + b)2p(hx2, x2i + b)2p

+c2 exp(s 2kx1  x1k2)exp(s 2kx2  x2k2)

(16)

is a hyperkernel.

5. Optimization Problems for Regularized Risk based Quality Functionals

We will now consider the optimization of the quality functionals utilizing hyperkernels. We choose
the regularized risk functional as the empirical quality functional; that is we set Qemp(k, X,Y ) :=
Rreg( f , X,Y ). It is possible to utilize other quality functionals, such as the Kernel Target Alignment
(Example 12). We focus our attention on the regularized risk functional, which is commonly used
in SVMs. Furthermore, we will only consider positive semidenite kernels. For a particular loss
function l(xi, yi, f (xi)), we obtain the regularized quality functional.
l Q
2 kkk2
H .

l(xi, yi, f (xi)) +

2k fk2

(17)

1
m

m(cid:229)

+

H k

min
kH

min
fH k

i=1

1056

l
HYPERKERNELS

By the representer theorem (Theorem 4 and Corollary 7) we can write the regularizers as

quadratic terms. Using the soft margin loss, we obtain

min

mina

1
m

m(cid:229)

i=1

max(0,1 yi f (xi)) +

2

a Ka +

l Q
2

b Kb

subject to b > 0

(18)

where a  Rm are the coefcients of the kernel expansion (5), and b  Rm2 are the coefcients of

the hyperkernel expansion (7).

For xed k, the problem can be formulated as a constrained minimization problem in f , and
subsequently expressed in terms of the Lagrange multipliers a
. However, this minimum depends
on k, and for efcient minimization we would like to compute the derivatives with respect to k. The
following lemma tells us how (it is an extension of a result in Chapelle et al. (2002)):

Lemma 10 Let x  Rm and denote by f (x,q ), ci : Rm  R convex functions, where f is parameter-
ized by q
. Let R(q ) be the minimum of the following optimization problem (and denote by x(q ) its
minimizer):

minimize

xRm

f (x,q ) subject to ci(x)  0 for all 1  i  n.

j

q R(q ) = D j

Then 
argument of f .

2 f (x(q ),q ), where j  N and D2 denotes the derivative with respect to the second

Proof At optimality we have a saddlepoint in the Lagrangian

 xL (x,a ) =  x f (x,q ) +

n(cid:229)

i=1

i xci(x) = 0.

(19)

the Kuhn-Tucker conditions have to hold, and in particular also (cid:229) n

i > 0 the condition ci(x) = 0 and therefore also 

q ci(x(q )) = 0 has to be satised.

i=1

i

q ci(x(q )) =

Furthermore, for all q
0, since for all a
Taking higher order derivatives with respect to q yields
 x
q # = 

i xci(x(q ))

q " n(cid:229)

0 = 

i=1

j

j

q (cid:20) x f (x,q )

 x

(cid:21) .

(20)

Here the last equality follows from (19). Next we use

j+1

f (x,q ) = 

j

q (cid:20)D2 f (x,q ) +  x f (x,q )

 x

(cid:21) = 

j

q D2 f (x,q ).

Repeated application then proves the claim.

Instead of directly minimizing Equation (18), we derive the dual formulation. Using the ap-
proach in Lanckriet et al. (2004), the corresponding optimization problems can be expressed as a
SDP. In general, solving a SDP would be take longer than solving a quadratic program (a traditional
SVM is a quadratic program). This reects the added cost incurred for optimizing over a class of
kernels.

Semidenite programming (Vandenberghe and Boyd, 1996) is the optimization of a linear ob-

jective function subject to constraints which are linear matrix inequalities and afne equalities.

1057

b
l
a
a
a


q

q

q
ONG, SMOLA AND WILLIAMSON

Denition 11 (Semidenite Program) A semidenite program (SDP) is a problem of the form:

min

x

cx

subject to F0 +

q(cid:229)

i=1

xiFi (cid:23) 0 and Ax = b

where x  Rp are the decision variables, A  Rpq, b  Rp, c  Rq, and Fi  Rrr are given.
In general, linear constraints Ax+a > 0 can be expressed as a semidenite constraint diag(Ax+a) (cid:23)
0, and a convex quadratic constraint (Ax + b)(Ax + b) cx d 6 0 can be written as

(cid:20)

I

Ax + b

(Ax + b) cx + d (cid:21) (cid:23) 0.

When t  R, we can write the quadratic constraint aAa 6 t as kA 1
quadratic constraints are simpler and faster to implement in a convex solver.

2 ak 6 t. In practice, linear and
We derive the corresponding SDP for Equation (17). The following proposition allows us to
derive a SDP from a class of general convex programs. It follows the approach in Lanckriet et al.
(2004), with some care taken with Schur complements of positive semidenite matrices (Albert,
1969), and its proof is omitted for brevity.
Proposition 12 (Quadratic Minimax) Let m, n, M  N, H : Rn  Rmm, c : Rn  Rm, be linear
maps. Let A  RMm and a  RM. Also, let d : Rn  R and G(x ) be a function and the further
constraints on x . Then the optimization problem
2xH(x )x c(x )x + d(x )
 1
H(x ) (cid:23) 0
Ax + a > 0
G(x ) (cid:23) 0

maximize

subject to

minimize

x Rn

xRm

(21)

can be rewritten as

minimize

t,x ,g

subject to 


1

diag(g )

2t + ag + d(x )
0
G(x )
0
0

0
0
0

0
0

H(x )

(Ag  c(x ))

0
0

t

(Ag  c(x ))




(22)

(cid:23) 0

in the sense that the x which solves (22) also solves (21).
Specically, when we have the regularized quality functional, d(x ) is quadratic, and hence we obtain
an optimization problem which has a mix of linear, quadratic and semidenite constraints.

Corollary 13 Let H, c, A and a be as in Proposition 12, and S (cid:23) 0. Then the solution x  to the

optimization problem

minimize

maximize

x

subject to

x S

2xH(x )x c(x )x + 1
 1
H(x ) (cid:23) 0
Ax + a > 0
x > 0

2

1058

(23)

x
x
HYPERKERNELS

can be found by solving the semidenite programming problem

2t + ag

t,t,x ,g

minimize

subject to

1
2t + 1
g > 0
x > 0
kS
(cid:20)
Proof By applying proposition 12, and introducing an auxiliary variable t which upper bounds the
quadratic term of x , the claim is proved.

2 x k2 6 t
H(x )
(Ag  c(x ))

(Ag  c(x ))

(cid:21) (cid:23) 0

(24)

t

1

 = e

. As we vary e

Comparing the objective function in (21) with (18), we observe that H(x ) and c(x ) are linear in
x . Let x
the constraints are still satised, but the objective function scales with
e . Since x
is the coefent in the hyperkernel expansion, this implies that we have a set of possible
kernels which are just scalar multiples of each other. To avoid this, we add an additional constraint
on x which is 1x = c, where c is a constant. This breaks the scaling freedom of the kernel matrix.
As a side-effect, the numerical stability of the SDP problems improves considerably. We chose a
linear constraint so that it does not add too much overhead to the optimization problem We make
one additional simplication of the optimization problem, which is to replace the upper bound of

the squared norm (kS

1

2 x k2 6 t) with and upper bound on the norm (kS

1

2 x k 6 t).

1

In our setting, the regularizer for controlling the complexity of the kernel is taken to be the
squared norm of the kernel in the Hyper-RKHS. By looking at the constraints of Equation (24), this

2 x k 6 t). Comparing this result to the SDP obtained in
is expressed as a bound on the norm (kS
Lanckriet et al. (2004, Theorem 16), we see that the corresponding regularizer in their setting is
tr(K) = c, where c is a constant. Hence the main difference between the two SDPs is the choice
of the regularizer for the kernel. However, the motivations of the two methods are different. This
paper sets out an induction framework for learning the kernel, and for a particular choice of Qemp,
namely the regularized risk functional, we obtain an SDP which has similarities to the approach of
Lanckriet et al. (2004). On the other hand, they start out with a transduction problem and derive the
optimization problem directly. It is unclear at this point which is the better approach.

From the general framework above (Corollary 13, we derive several examples of machine learn-
ing problems, specically binary classication, regression, and single class (also known as novelty
detection) problems. The following examples illustrate our method for simultaneously optimizing
over the class of kernels induced by the hyperkernel, as well as the hypothesis class of the machine
learning problem. We consider machine learning problems based on kernel methods which are de-
rived from (17). The derivation is essentially by application of Corollary 13 with the two additional
conditions above.

6. Examples of Hyperkernel Optimization Problems
In this section, we dene the following notation. For p, q, r  Rn, n  N let r = p  q be dened
as element by element multiplication, ri = pi  qi (the Hadamard product, or the . operation in
Matlab). The pseudo-inverse (also known as the Moore-Penrose inverse) of a matrix K is denoted
K. Let ~K be the m2 by 1 vector formed by concatenating the columns of an m by m matrix.

1059

x
ONG, SMOLA AND WILLIAMSON

We dene the hyperkernel Gram matrix K by putting together m2 of these vectors, that is we set
p,q=1. Other notations include: the kernel matrix K = reshape(Kb ) (reshaping a m2 by 1
K = [~Kpq]m
vector, Kb
, to a m by m matrix), Y = diag(y) (a matrix with y on the diagonal and zero everywhere
else), G(b ) = Y KY (the dependence on b
is made explicit), I the identity matrix, 1 a vector of ones
and 1mm a matrix of ones. Let w be the weight vector and boffset the bias term in feature space,
that is the hypothesis function in feature space is dened as g(x) = wf (x) + boffset where f () is the
feature mapping dened by the kernel function k.
The number of training examples is assumed to be m, that is Xtrain = {x1, . . . , xm} and Ytrain =
y = {y1, . . . , ym}. Where appropriate, g and c are Lagrange multipliers, while h
and x are vectors
of Lagrange multipliers from the derivation of the Wolfe dual for the SDP, b are the hyperkernel
coefcients, t1 and t2 are the auxiliary variables. When h  Rm, we dene h > 0 to mean that each
i > 0 for i = 1, . . . , m.
We derive the corresponding SDP for the case when Qemp is a C-SVM (Example 7). Derivations

of the other examples follow the same reasoning, and are omitted.

Example 7 (Linear SVM (C-parameterization)) A commonly used support vector classier, the
C-SVM (Bennett and Mangasarian, 1992, Cortes and Vapnik, 1995) uses an 1 soft margin, l(xi, yi, f (xi)) =
max(0,1 yi f (xi)), which allows errors on the training set. The parameter C is given by the user.
Setting the quality functional Qemp(k, X,Y ) = min fH
1
2k fk2

(cid:229) m
i=1 l(xi, yi, f (xi)) + 1

l Q
2 kkk2

2kwk2
H ,

C
m

m(cid:229)

C
m

+

H k

H

(25)

min
fH k

min
kH
subject to yi f (xi) > 1 z

i +

i=1

i

i > 0

Recall the dual form of the C-SVM,

max
a Rm
subject to

(cid:229) m
i=1

0 6 a

(cid:229) m
i=1

jyiy jk(xi, x j)

ia
iyi = 0

i  1
2
(cid:229) m
i=1
i 6 C
m for all i = 1, . . . , m.

By considering the optimization problem dependent on f in (25), we can use the derivation of
H = b Kb due to the
the dual problem of the standard C-SVM. Observe that we can rewrite kkk2
representer theorem for hyperkernels. Substituting the dual C-SVM problem into (25), we get the
following matrix equation,

a G(b )a +

2

maxa

1a  1
min
subject to a y = 0
0 6 a 6 C
m
b > 0

l Q
2

b Kb

, q = b

(26)

This is of the quadratic form of Corollary 13 where x = a

S = Cl QK, the constraints are A =(cid:2) y y

Corollary 13, we obtain the corresponding SDP.

I I (cid:3) and a =(cid:2) 0 0 0

, H(q ) = G(b ), c(q ) = 1,
m1 (cid:3). Applying

C

1060

h
z
z
a
a
a
b
HYPERKERNELS

The proof of Proposition 12 uses the Lagrange method. As an illustration of how this proof

proceeds, we derive it for this special case of the C-SVM. The Lagrangian associated with (26) is

L(a

,b ,g ,h

,x ) = 1a 

1
2

a G(b )a +

l Q
2

b Kb + g ya + h a  x (a 

C
m

1),

where b > 0,h > 0,x > 0. The minimum is achieved at

and the corresponding dual optimization problem is

a = G(b )(g y + 1 + h  x ),

minimize

b ,g ,h

,x

zG(b )z +

1
2

x 1 +

C
m

l Q
2

b Kb ,

where z = g y + 1 + h  x . From this point, we replace the quadratic terms with auxiliary variables
t1 and t2, and apply the Schur complement lemma (Albert, 1969). The resulting SDP after replacing
kK 1

2 b k 6 t2, and introducing the scale breaking constraint 1b = 1 is

2 b k2 6 t2 by kK 1

,x

b ,g ,h

x 1 +

1
2t1 + C
m

l Q
minimize
2 t2
subject to h > 0,x > 0,b > 0
2 b k 6 t2,1b = 1
kK 1
(cid:20) G(b )
t1 (cid:21) (cid:23) 0.
z

z

(27)

, which optimizes the corresponding La-

Note that the value of the support vector coefcients, a
grange function is G(b )z, and the classication function, f = sign(K(a  y) boffset), is given by
f = sign(KG(b )(y z) g ).
Example 8 (Linear SVM (n -parameterization)) An alternative parameterization of the 1 soft
margin was introduced by Scholkopf et al. (2000), where the user dened parameter n  [0,1] con-
trols the fraction of margin errors and support vectors. Using n -SVM as Qemp, that is, for a given
H  n
2kwk2
i > 0 for all
, Qemp(k, X,Y ) = min fH
i = 1, . . . , m, the corresponding SDP is given by
2t1  c

subject to yi f (xi) > r  z

n + x  1

i and z

l Q
2 t2

(cid:229) m
i=1

i + 1

1
m

1

minimize
b ,g ,h
subject to c > 0,h > 0,x > 0,b > 0

m +

,x ,c

2 b k 6 t2,1b = 1
kK 1
(cid:20) G(b )
t1 (cid:21) (cid:23) 0
z

z

(28)

The value of a which optimizes the corresponding Lagrange function is G(b )z, and the classi-

where z = g y + c 1 + h  x .
cation function, f = sign(K(a  y) boffset), is given by f = sign(KG(b )(y z) g ).

1061

n
z
r
ONG, SMOLA AND WILLIAMSON

Example 9 (Quadratic SVM or Lagrangian SVM) Instead of using an 1 loss class, Mangasar-
ian and Musicant (2001) use an 2 loss class,

l(xi, yi, f (xi)) =(cid:26) 0

(1 yi f (xi))2

if yi f (xi) > 1
otherwise

,

and regularized the weight vector as well as the bias term. The empirical quality functional derived
from this is Qemp(k, X,Y ) = min fH
i and
i > 0 for all i = 1, . . . , m. The resulting dual SVM problem has fewer constraints, as is evidenced
by the smaller number of Lagrange multipliers needed in the corresponding SDP below.

offset) subject to yi f (xi) > 1 z

2 (kwk2

z 2
i + 1

H + b2

(cid:229) m
i=1

1
m

1
2t1 +

minimize
subject to h > 0,b > 0

b ,h

l Q
2 t2

2 b k 6 t2,1b = 1
kK 1
(h + 1)
(cid:20) H(b )
(h + 1)

t1

(29)

(cid:21) (cid:23) 0

where H(b ) = Y (K + 1mm + l mI)Y , and z = g 1 + h  x .

The value of a which optimizes the corresponding Lagrange function is H(b )(h + 1), and the
f = sign(K(a  y)  boffset), is given by f = sign(KH(b )((h + 1)  y) +

classication function,
y(H(b )(h + 1))).

Example 10 (Single class SVM or Novelty Detection) For unsupervised learning, the single class
SVM computes a function which captures regions in input space where the probability density
is in some sense large (Scholkopf et al., 2001). A suitable quality functional Qemp(k, X,Y ) =
i > 0 for all i = 1, . . . , m, and r > 0.
min fH
The corresponding SDP for this problem is

H r subject to f (xi) > r z

2kwk2

i, and z

(cid:229) m
i=1

i + 1

1
n m

1

n m  g +
minimize
subject to h > 0,x > 0,b > 0

2t1 + x  1

b ,g ,h

,x

l Q
2n t2

2 b k 6 t2
kK 1
(cid:20) K z
z t1 (cid:21) (cid:23) 0

(30)

data to be classied as novel.

where z = g 1 + h  x , and n  [0,1] is a user selected parameter controlling the proportion of the
The score to be used for novelty detection is given by f = Ka  boffset, which reduces to f =

h  x , by substituting a = K(g 1 + h  x ), boffset = g 1 and K = reshape(Kb ).
Example 11 (n -Regression) We derive the SDP for n
regression (Scholkopf et al., 2000), which
insensitive tube for regression. As in the n -SVM case in Example 8,
automatically selects the e
controls the fraction of errors and support vectors. Using the e -
the user dened parameter n
insensitive loss, l(xi, yi, f (xi)) = max(0,|yi f (xi)|e ), and the n -parameterized quality functional,
Qemp(k, X,Y ) = min fH C(cid:0)n
i, yi  f (xi) 6 e  z i ,

i + z i )(cid:1) subject to f (xi) yi 6 e  z

e + 1
m

i=1(z
(cid:229) m

1062

z
z
HYPERKERNELS

z ()
i > 0 for all i = 1, . . . , m and e > 0, the corresponding SDP is

1
2t1 +

minimize
b ,g ,h
subject to c > 0,h > 0,x > 0,b > 0

ml +

,x ,c

l + x  1

l Q
2l t2

,

(31)

z

2 b k 6 t2,1b = stddev(Ytrain)
kK 1
(cid:20) F(b )
z
1 (cid:21) + h  x  c (cid:20) 1

t1 (cid:21) (cid:23) 0
1 (cid:21) and F(b ) =(cid:20) K K
K (cid:21).

K

y (cid:21) g (cid:20) 1

where z =(cid:20) y
The Lagrange function is minimized for a = F(b )z, and substituting into f = Ka  boffset, we
obtain the regression function f =(cid:2) K K (cid:3)F(b )z g .

Example 12 (Kernel Target Alignment) For the Kernel Target Alignment approach (Cristianini
et al., 2002), Qemp = tr(Kyy) = yKy, we directly minimize the regularized quality functional,
obtaining the following optimization problem (Lanckriet et al., 2002),

l Q
2 t2

1
minimize
2t1 +
subject to b > 0
2 b k 6 t2,1b = 1
kK 1
(cid:20) K y
y t1 (cid:21) (cid:23) 0.

(32)

Note that for the case of Kernel Target Alignment, Qemp does not provide a direct formulation for
the hypothesis function, but instead, it determines a kernel matrix K. This kernel matrix, K, can be
utilized in a traditional SVM, to obtain a classication function.

7. Experiments

In the following experiments, we use data from the UCI repository. Where the data attributes are
numerical, we did not perform any preprocessing of the data. Boolean attributes are converted
to {1,1}, and categorical attributes are arbitrarily assigned an order, and numbered {1,2, . . .}.
The optimization problems in Section 6 were solved with an approximate hyperkernel matrix as de-
scribed in Section 7.1. The SDPs were solved using SeDuMi (Sturm, 1999), and YALMIP (Lofberg,
2002) was used to convert the equations into standard form. We used the hyperkernel for automatic
relevance determination dened by (14) for the hyperkernel optimization problems. The scaling
freedom that (14) provides for each dimension means we do not have to normalize data to some
arbitrary distribution.

For the classication and regression experiments, the datasets were split into 100 random permu-
tations of 60% training data and 40% test data. We deliberately did not attempt to tune parameters
and instead made the following choices uniformly for all datasets in classication, regression and
novelty detection:

 The kernel width s
i, for each dimension, was set to 50 times the 90% quantile of the value
of |xi  x j| over the training data. This ensures sufcient coverage without having too wide a
kernel. This value was estimated from a 20% random sampling of the training data.

1063

c
n
b
ONG, SMOLA AND WILLIAMSON

SVMs). This has commonly been reported to yield good results.

 l was adjusted so that
1
l m = 100 (that is C = 100 in the Vapnik-style parameterization of
 n = 0.3 for classication and regression. While this is clearly suboptimal for many datasets,
we decided to choose it beforehand to avoid having to change any parameter. Clearly we
could use previous reports on generalization performance to set n
to this value for better
performance. For novelty detection, n = 0.1 (see Section 7.6 for details).
 l h for the Harmonic Hyperkernel was chosen to be 0.6, giving adequate coverage over various
kernel widths in (12) (small l h emphasizes wide kernels almost exclusively, l h close to 1 will
treat all widths equally).
 The hyperkernel regularization constant was set to l Q = 1.
 For the scale breaking constraint 1b = c, c was set to 1 for classication as the hypothesis
class only involves the sign of the trained function, and therefore is scale free. However,
for regression, c := stddev(Ytrain) (the standard deviation of the training labels) so that the
hyperkernel coefcients are of the same scale as the output (the constant offset boffset takes
care of the mean).

In the following experiments, the hypothesis function is computed using the variables of the
SDP. In certain cases, numerical problems in the SDP optimizer or in the pseudo-inverse may pre-
vent this hypothesis from optimizing the regularized risk for the particular kernel matrix. In this
case, one can use the kernel matrix K from the SDP and obtain the hypothesis function via a stan-
dard SVM.

7.1 Low Rank Approximation

Although the optimization of (17) has reduced the problem of optimizing over two possibly in-
nite dimensional Hilbert spaces to a nite problem, it is still formidable in practice as there are m2
coefcients for b
. For an explicit expansion of type (15) one can optimize in the expansion coef-
cients ki(x)ki(x) directly, which leads to a quality functional with an 2 penalty on the expansion
coefcients. Such an approach is appropriate if there are few terms in (15).

In the general case (or if the explicit expansion has many terms), one can use a low-rank approx-
imation, as described by Fine and Scheinberg (2001) and Zhang (2001). This entails picking from

(cid:8)k((xi, x j),)|1  i, j  m2(cid:9) a small fraction of terms, p (where m2  p), which approximate k on
Xtrain Xtrain sufciently well. In particular, we choose an m p truncated lower triangular matrix G
such that kPKPGGkF 6 d , where P is the permutation matrix which sorts the eigenvalues of K
into decreasing order, and d
is the level of approximation needed. The norm, kkF is the Frobenius
norm. In the following experiments, the hyperkernel matrix was approximated to d = 106 using
the incomplete Cholesky factorization method (Bach and Jordan, 2002).

7.2 Classication Experiments
Several binary classication datasets1 from the UCI repository were used for the experiments. A
set of synthetic data (labeled syndata in the results) sampled from two Gaussians was created to
illustrate the scaling freedom between dimensions. The rst dimension had a standard deviation
of 1000 whereas the second dimension had a standard deviation of 1 (a sample result is shown in
Figure 1). The results of the experiments are shown in Table 3.

1. We classied window vs. non-window for glass data, the other datasets are all binary.

1064

HYPERKERNELS

From Table 3, we observe that our method achieves state of the art results for all the datasets,
except the heart dataset. We also achieve results much better than previously reported for the
credit dataset. Comparing the results for C-SVM and Tuned SVM, we observe that our method is
always equally good, or better than a C-SVM tuned using 10-fold cross validation.

Data

syndata
pima

ionosph
wdbc
heart
thyroid
sonar
credit
glass

C-SVM
2.82.4
23.52.0
6.61.8
3.31.2
19.73.3
7.23.2
14.83.7
14.61.8
6.02.4

n -SVM Lag-SVM Best other CV Tuned SVM (C)
5.95.4 (108)
1.91.9
24.12.1 (104)
27.72.1
6.11.8 (103)
6.71.8
5.21.4 (106)
3.81.2
23.23.7 (104)
19.32.4
5.22.2 (105)
10.14.0
15.34.1 (103)
15.33.7
15.32.0 (108)
13.71.5
7.22.7 (103)
8.92.6

2.42.2
23.61.9
6.41.9
3.01.1
20.12.8
6.23.1
14.73.6
14.71.8
6.02.2

NA
23.5
5.8
3.2
16.0
4.4
15.4
22.8
NA

Table 3: Hyperkernel classication: Test error and standard deviation in percent. The second, third
and fourth columns show the results of the hyperkernel optimizations of C-SVM (Exam-
ple 7), n -SVM (Example 8) and Lagrangian SVM (Example 9) respectively. The results
in the fth column shows the best results from (Freund and Schapire, 1996, Ratsch et al.,
2001, Meyer et al., 2003). The rightmost column shows a C-SVM tuned in the traditional
way. A Gaussian RBF kernel was tuned using 10-fold cross validation on the training data,
with the best value of C shown in brackets. A grid search was performed on (C,s ). The
values of C tested were {102,101, . . . ,109}. The values of the kernel width, s
, tested
were between 10% and 90% quantile of the distance between a pair of sample of points in
the data. These quantiles were estimated by a random sample of 20% of the training data.

7.3 Effect of l Q and l h on Classication Error
In order to investigate the effect of varying the hyperkernel regularization constant, l Q, and the
Harmonic Hyperkernel parameter, l h, we performed experiments using the C-SVM hyperkernel
optimization (Example 7). We performed two sets of experiments with each of our chosen datasets.
The results shown in Table 4.

From Table 4, we observe that the variation in classication accuracy over the whole range
of the hyperkernel regularization constant, l Q is less than the standard deviation of the classica-
tion accuracies of the various datasets (compare with Table 3). This demonstrates that our method
is quite insensitive to the regularization parameter over the range of values tested for the various
datasets.

The method shows a higher sensitivity to the harmonic hyperkernel parameter. Since this pa-
rameter effectively selects the scale of the problem, by selecting the width of the kernel, it is to
be expected that each dataset would have a different ideal value of l h. It is to be noted that the
generalization accuracy at l h = 0.6 is within one standard deviation (see Table 3 and 4) of the best
accuracy achieved over the whole range tested.

1065

ONG, SMOLA AND WILLIAMSON

Data

syndata
pima

ionosph
wdbc
heart
thyroid
sonar
credit
glass

l h

l Q

Error Deviation

Error Deviation

3.01.1
25.72.6
6.61.0
2.90.4
19.72.0
6.52.8
15.71.6
16.01.8
5.91.0

2.2
1.9
1.7
0.9
3.0
3.0
3.4
1.6
2.3

2.80.0
24.50.1
7.20.1
2.70.2
19.40.9
6.70.3
15.10.2
14.70.4
5.20.3

2.2
1.5
1.9
0.8
2.8
3.7
3.3
1.6
2.3

Table 4: Effect of varying l h and l Q on classication error. In the left experiment, we xed l Q =
1, and l h was varied with the values l h = {0.1,0.2, . . . ,0.9,0.92,0.94,0.96,0.98}.In the
right, we set l h = 0.6 and varied l Q = {104,103, . . . ,105}. The error columns (columns

2 and 4) report the average error on the test set and the standard deviation of the error
over the different parameter settings. The deviation columns (columns 3 and 5) report the
average standard deviation over 10 random 60%/40% splits.

7.4 Computational Time

One of the concerns of an SDP optimization problem is the computational complexity.
Instead
of performing worst case analysis of computational complexity, we perform an empirical test to
investigate the scaling behaviour of the proposed method. The total computation time for the rst 10
splits of the data was measured, and the average time taken for each split was computed and plotted
on a log scale plot in Figure 4. The slope of the graph demonstrates that we have an approximately
cubic scaling in computational time.

7.5 Regression Experiments

In order to demonstrate that we can solve problems other than binary classication using the same
framework, we performed some experiments using regression and novelty detection datasets. The
results of the regression experiments are shown in Table 5. We used the same parameter settings as
in the previous section.

Comparing the second and fourth columns, we observe that the hyperkernel optimization prob-
lem performs better than a e -SVR tuned using cross validation for all the datasets except the servo
dataset. Meyer et al. (2003) used a 90%/10% split of the data for their experiments, while we used
a 60%/40% split, which may account for the better performance in the cpu and servo datasets. The
reason for the much better rate on the auto imports dataset remains a mystery.

7.6 Novelty Detection

We applied the single class support vector machine to detect outliers in the USPS data. The test set
of the default split in the USPS database was used in the following experiments. The parameter n
was set to 0.1 for these experiments, hence selecting up to 10% of the data as outliers.

1066

HYPERKERNELS

Figure 4: A log scale plot of computational time (in seconds), measured using MATLABs cputime,
against the number of examples in the respective datasets. The slope of the least squares
t through the points are 3.13, 3.05 and 3.03 for C-SVM (Example 7), n -SVM (Exam-
ple 8) and Lag-SVM (Example 9) respectively, demonstrating that the algorithms have
approximately cubic scaling.

Data

auto-mpg

boston

auto imports(106)

cpu(103)

servo

n -SVR Best other CV Tuned e -SVR
9.471.55
15.784.30
7.515.33
12.0220.73
0.620.25

7.830.96
12.963.38
5.912.41
4.413.64
0.740.26

7.11
9.60
0.25
3.16
0.25

Table 5: Hyperkernel regression: Mean Squared Error. The second column shows the results from
the hyperkernel optimization of the n -regression (Example (11)). The results in the third
column shows the best results from (Meyer et al., 2003). The rightmost column shows a
e -SVR with a gaussian kernel tuned using 10-fold cross validation on the training data.
Similar to the classication setting, grid search was performed on (C,s ). The values of C
tested were {102,101, . . . ,109}. The values of the kernel width, s
, tested were between
the 10% and 90% quantiles of the distance between a pair of sample of points in the data.
These quantiles were estimated by a random 20% sample of the training data.

1067

ONG, SMOLA AND WILLIAMSON

Figure 5: Top rows: Images of digits 1 and 2, considered novel by algorithm; Bottom: typical

images of digits 1 and 2.

Since there is no quantitative method for measuring the performance of novelty detection, we
cannot directly compare our results with the traditional single class SVM. We can only subjectively
conclude, by visually inspecting a sample of the digits, that our approach works for novelty detection
of USPS digits. Figure 5 shows a sample of the digits. We can see that the algorithm identies
novel digits, such as in the top two rows of Figure 5. The bottom two rows shows a sample of
digits which have been deemed to be common.

8. Summary and Outlook

The regularized quality functional allows the systematic solution of problems associated with the
choice of a kernel. Quality criteria that can be used include Kernel Target Alignment, regularized
risk and the log posterior. The regularization implicit in our approach allows the control of overt-
ting that occurs if one optimizes over a too large a choice of kernels.

We have shown that when the empirical quality functional is the regularized risk functional,
the resulting optimization problem is convex, and in fact is a SDP. This SDP, which learns the best
kernel given the data, has a Bayesian interpretation in terms of a hierarchical Gaussian process. We
dene more general kernels which may have many free parameters, and optimize over them without
overtting. The experimental results on classication demonstrate that it is possible to achieve state
of the art performance using our approach with no manual tuning. Furthermore, the same framework
and parameter settings work for various data sets as well as regression and novelty detection.

This approach makes support vector based estimation approaches more automated. Parameter
adjustment is less critical compared to when the kernel is xed, or hand tuned. Future work will fo-
cus on deriving improved statistical guarantees for estimates derived via hyperkernels which match
the good empirical performance.

Acknowledgments

1068

HYPERKERNELS

The authors would like to thank Stephane Canu, Laurent El Ghaoui, Michael Jordan, John Lloyd,
Daniela Pucci de Farias, Matthias Seeger, Grace Wahba and the referees for their helpful com-
ments and suggestions. The authors also thank Alexandros Karatzoglou for his help with SVLAB.
National ICT Australia is funded through the Australian Governments Backing Australias Ability
initiative, in part through the Australian Research Council.

