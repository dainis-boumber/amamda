Abstract
Can we detect low dimensional structure in high dimensional data sets of images and video? The problem of
dimensionality reduction arises often in computer vision and pattern recognition. In this paper, we propose a
new solution to this problem based on semidefinite programming. Our algorithm can be used to analyze high
dimensional data that lies on or near a low dimensional manifold. It overcomes certain limitations of previous
work in manifold learning, such as Isomap and locally linear embedding. We illustrate the algorithm on easily
visualized examples of curves and surfaces, as well as on actual images of faces, handwritten digits, and solid
objects.

Keywords
computer vision, pattern recognition

Disciplines
Artificial Intelligence and Robotics

Comments
Copyright  2004 IEEE. Reprinted from Proceedings of the 2004 IEEE Computer Society Conference on
Computer Vision and Pattern Recognition, CVPR 2004, held 27 June - 2 July 2004. Volume 2, pages 988-995.
Publisher URL: http://dx.doi.org/10.1109/CVPR.2004.1315272

This material is posted here with permission of the IEEE. Such permission of the IEEE does not in any way
imply IEEE endorsement of any of the University of Pennsylvania's products or services. Internal or personal
use of this material is permitted. However, permission to reprint/republish this material for advertising or
promotional purposes or for creating new collective works for resale or redistribution must be obtained from
the IEEE by writing to pubs-permissions@ieee.org. By choosing to view this document, you agree to all
provisions of the copyright laws protecting it.

This conference paper is available at ScholarlyCommons: http://repository.upenn.edu/cis_papers/1

Unsupervised Learning of Image Manifolds by Semidenite Programming

Kilian Q. Weinberger and Lawrence K. Saul

Department of Computer and Information Science

University of Pennsylvania, Levine Hall

3330 Walnut Street, Philadelphia, PA 19104-6389

{kilianw,lsaul}@cis.upenn.edu

Abstract

Can we detect low dimensional structure in high dimen-
sional data sets of images and video? The problem of di-
mensionality reduction arises often in computer vision and
pattern recognition. In this paper, we propose a new solu-
tion to this problem based on semidenite programming.
Our algorithm can be used to analyze high dimensional
data that lies on or near a low dimensional manifold. It
overcomes certain limitations of previous work in mani-
fold learning, such as Isomap and locally linear embedding.
We illustrate the algorithm on easily visualized examples of
curves and surfaces, as well as on actual images of faces,
handwritten digits, and solid objects.

1. Introduction

Many data sets of images and video are characterized by
far fewer degrees of freedom than the actual number of pix-
els per image. The problem of dimensionality reduction is
to understand and analyze these images in terms of their
basic modes of variabilityfor example, the pose and ex-
pression of a human face, or the rotation and scaling of a
solid object. Mathematically, we can view an image as a
point in a high dimensional vector space whose dimension-
ality is equal to the number of pixels in the image [3, 20].
If the images in a data set are effectively parameterized by
a small number of continuous variables, then they will lie
on or near a low dimensional manifold in this high dimen-
sional space [12]. This paper is concerned with the unsuper-
vised learning of such image manifolds.

Beyond its applications in computer vision, manifold
learning is best described as a problem at the intersection
of statistics, geometry, and computation. The problem is il-
lustrated in Fig. 1. Given high dimensional data sampled
from a low dimensional manifold, how can we efciently
compute a faithful (nonlinear) embedding? In the last few

years, researchers have uncovered a large family of algo-
rithms for computing such embeddings from the top or
bottom eigenvectors of an appropriately constructed ma-
trix. These algorithmsincluding Isomap [19], locally lin-
ear embedding (LLE) [14, 15], hessian LLE [8], Laplacian
eigenmaps [1], and others [5]can reveal low dimensional
manifolds that are not detected by classical linear methods,
such as principal component analysis (PCA) [11].

Our main contribution in this paper is a new algorithm
for manifold learning based on semidenite programming.
Like Isomap and LLE, it relies on efcient and tractable

Figure 1. The problem of manifold learning,
illustrated for N = 800 data points sampled
from a Swiss roll. (1). A discretized man-
ifold is revealed by connecting each data
point and its k = 6 nearest neighbors (2).
An unsupervised learning algorithm unfolds
the Swiss roll while preserving the local ge-
ometry of nearby data points (3). Finally, the
data points are projected onto the two dimen-
sional subspace that maximizes their vari-
ance, yielding a faithful embedding of the
original manifold (4).

Proceedings of the 2004 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR04)
1063-6919/04 $20.00  2004 IEEE

optimizations that are not plagued by spurious local min-
ima. Interestingly, though, our algorithm is based on a com-
pletely different geometric intuition (and optimization), and
it overcomes certain limitations of previous work.

mainly conned to a low dimensional subspace; in this case,
their eigenvalues also reveal the correct underlying dimen-
sionality. They do not generally succeed, however, in the
case that the inputs lie on a low dimensional manifold.

2. Dimensionality Reduction

2.2. From Subspaces to Manifolds

We study dimensionality reduction as a problem in un-
supervised learning. Given N high dimensional
inputs
(cid:1)XiRD (where i = 1, 2, . . . , N), the problem is to com-
pute outputs (cid:1)Yi  Rd in one-to-one correspondence with
the inputs that provide a faithful embedding in d < D di-
mensions. By faithful, we mean that nearby points re-
main nearby and that distant points remain distant; we
shall make this intuition more precise in what follows. Ide-
ally, an unsupervised learning algorithm should also
estimate the intrinsic dimensionality d of the manifold sam-
pled by the inputs (cid:1)Xi.

Our algorithm for manifold learning builds on classical
linear methods for dimensionality reduction. We therefore
begin by briey reviewing principal component analysis
(PCA) [11] and metric multidimensional scaling (MDS) [6].
The generalization from subspaces to manifolds is then
made by introducing the idea of local isometry.

2.1. Linear Methods

PCA and MDS are based on simple geometric intuitions.
In PCA, the inputs are projected into the lower dimensional
subspace that maximizes the projected variance; the basis
vectors of this subspace are given by the top eigenvectors of
the DD covariance matrix, C = 1
i . (Here and
in what follows, we assume without loss of generality that
the inputs are centered on the origin:

(cid:1)Xi =(cid:1)0.)

(cid:1)
(cid:1)

(cid:1)X T

(cid:1)Xi

N

i

i

In MDS with classical scaling, the inputs are projected
into the subspace that best preserves their pairwise squared
distances | (cid:1)Xi (cid:1)Xj|2 or, as done in practice, their dot prod-
ucts (cid:1)Xi  (cid:1)Xj. The outputs of MDS are computed from the
top eigenvectors of the N N Gram matrix with elements
Gij = (cid:1)Xi (cid:1)Xj. Note that a set of vectors is determined up to
rotation by its Gram matrix of dot products.

Though based on different geometric intuitions, PCA
and MDS yield the same resultsessentially a rotation of
the inputs followed by a projection into the subspace with
the highest variance. The correlation matrix of PCA and
the Gram matrix of MDS have the same rank and nonzero
eigenvalues up to a constant factor. Both matrices are semi-
positive denite, and gaps in their eigenvalue spectra indi-
cate that the high dimensional inputs XiRD lie to a good
approximation in a lower dimensional subspace of dimen-
sionality d, where d is the number of appreciably positive
eigenvalues. These linear methods for dimensionality re-
duction generate faithful embeddings when the inputs are

We will refer to any method that computes a low dimen-
sional embedding from the eigenvectors of an appropriately
constructed matrix as a method in spectral embedding. If
PCA and MDS are linear methods in spectral embedding,
what are their nonlinear counterparts? In fact, there are sev-
eral, most of them differing in the geometric intuition they
take as starting points and in the generalizations of linear
transformations that they attempt to discover.

The nonlinear method we propose in this paper is based
fundamentally on the notion of isometry. (For the sake of
exposition, we defer a discussion of competing nonlinear
methods based on isometries [8, 19] to section 5.) For-
mally, two Riemannian manifolds are said to be isometric
if there is a diffeomorphism such that the metric on one
pulls back to the metric on the other. Informally, an isom-
etry is a smooth invertible mapping that looks locally like
a rotation plus translation, thus preserving distances along
the manifold. Intuitively, for two dimensional surfaces, the
class of isometries includes whatever physical transforma-
tions one can perform on a sheet of paper without intro-
ducing holes, tears, or self-intersections. Many interesting
image manifolds are isometric to connected subsets of Eu-
clidean space [7].

i=1 and Y = {(cid:1)Yi}N

Isometry is a relation between manifolds, but we can ex-
tend the notion in a natural way to data sets. Consider two
data sets X = { (cid:1)Xi}N
i=1 that are in one-
to-one correspondence. Let the N N binary matrix  in-
dicate a neighborhood relation on X and Y , such that we
regard (cid:1)Xj as a neighbor of (cid:1)Xi if and only if ij = 1 (and
similarly, for (cid:1)Yj and (cid:1)Yi). We will say that the data sets X
and Y are locally isometric under the neighborhood rela-
tion  if for every point (cid:1)Xi, there exists a rotation, reec-
tion and/or translation that maps (cid:1)Xi and its neighbors pre-
cisely onto (cid:1)Yi and its neighbors.

We can translate the above denition into various sets of
equality constraints on X and Y . To begin, note that the lo-
cal mapping between neighborhoods will exist if and only if
the distances and angles between points and their neighbors
are preserved. Thus, whenever both (cid:1)Xj and (cid:1)Xk are neigh-
bors of (cid:1)Xi (that is, ijik = 1), for local isometry we must
(cid:2)
have that:
(cid:1)Yi (cid:1)Yj

(cid:1)Xi (cid:1)Xk

(cid:1)Xi (cid:1)Xj

(cid:1)Yi (cid:1)Yk

(cid:3)

(cid:2)

(cid:3)

(cid:2)

(cid:3)

.

(1)

(cid:2)





=

(cid:3)

Eq. (1) is sufcient for local isometry because the triangle
formed by any point and its neighbors is determined up to
rotation, reection and translation by specifying the lengths

Proceedings of the 2004 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR04)
1063-6919/04 $20.00  2004 IEEE

of two sides and the angle between them. In fact, such a tri-
angle is similarly determined by specifying the lengths of
all its sides. Thus, we can also say that X and Y are lo-
cally isometric under  if whenever (cid:1)Xi and (cid:1)Xj are them-
selves neighbors (that is, ij = 1) or are common neigh-
bors of another point in the data set (that is, [T ]ij > 0),
we have:

(cid:4)(cid:4)(cid:4)(cid:1)Yi (cid:1)Yj

(cid:4)(cid:4)(cid:4)2

(cid:4)(cid:4)(cid:4) (cid:1)Xi (cid:1)Xj

(cid:4)(cid:4)(cid:4)2

=

.

(2)

This is an equivalent characterization of local isometry as
eq. (1), but expressed only in terms of pairwise distances.
Finally, we can express these constraints purely in terms of
dot products. Let Gij = (cid:1)Xi (cid:1)Xj and Kij = (cid:1)Yi (cid:1)Yj denote the
Gram matrices of the inputs and outputs, respectively. We
can rewrite eq. (2) as:

Kii+KjjKijKji = Gii+GjjGijGji.

(3)

Eq. (3) expresses the conditions for local isometry purely
in terms of Gram matrices; it is in fact this formulation that
will form the basis of our algorithm for manifold learning.

3. Semidenite Embedding

We can now formulate the problem of manifold learn-
ing more precisely, taking as a starting point the notion of
local isometry. In particular, given N inputs (cid:1)Xi  RD and
a prescription for identifying neighboring inputs, can we
nd N outputs (cid:1)Yi  Rd, where d < D, such that the in-
puts and outputs are locally isometric, or at least approxi-
mately so? Alternatively, we can state the problem in terms
of Gram matrices: can we nd a Gram matrix Kij that sat-
ises the constraints in eq. (3), and for which the vectors (cid:1)Yi
(which are determined up to a rotation by the elements of
the Gram matrix) lie in a subspace of dimensionality d < D,
or at least approximately lie in such a subspace? In this sec-
tion, we show how this can be done by a constrained opti-
mization over the cone of semidenite matrices.

Like PCA and MDS, the algorithm we propose for man-
ifold learning is based on a simple geometric intuition.
Imagine each input (cid:1)Xi as a steel ball that is connected
to its k nearest neighbors by rigid rods. The effect of the
rigid rods is to x the distances and angles between near-
est neighbors, no matter what other forces are applied to
the inputs. Now imagine that the inputs are pulled apart,
maximizing their total variance subject to the constraints
imposed by the rigid rods. Fig. 1 shows the unraveling ef-
fect of this transformation on inputs sampled from the Swiss
roll. The goal of this section is to formalize the steps of this
transformationin particular, the constraints that must be
satised by the nal solution, and the nature of the opti-
mization that must be performed.

3.1. Constraints

The constraints that we need to impose for local isome-
try are naturally represented by a graph with N nodes, one
for each input. Consider the graph formed by connecting
each input to its k nearest neighbors, where k is a free pa-
rameter of the algorithm. For simplicity, we assume that the
graph formed in this way is connected; if not, then each con-
nected component should be analyzed separately. The con-
straints for local isometry under this neighborhood relation
are simply to preserve the lengths of the edges in this graph,
as well as the angles between edges at the same node. In
practice, it is easier to deal only with constraints on dis-
tances, as opposed to angles. To this end, let us further con-
nect the graph by adding edges between the neighbors of
each node (if they do not already exist). Now by preserv-
ing the distances of all edges in this new graph, we preserve
both the distances of edges and the angles between edges in
the original graphbecause if all sides of a triangle are pre-
served, so are its angles.

In addition to imposing the constraints represented by
the neighborhood graph, we also constrain the outputs (cid:1)Yi
to be centered on the origin:(cid:5)

(cid:1)Yi = (cid:1)0.

i

(4)

Eq. (4) simply removes a translational degree of freedom
from the nal solution. The centering constraint can be ex-
pressed in terms of the Gram matrix Kij as follows:

(cid:5)

(cid:4)(cid:4)(cid:4)

(cid:1)Yi

i

(cid:5)

(cid:4)(cid:4)(cid:4)2

=

0 =

(cid:5)

(cid:1)Yi  (cid:1)Yj =

Kij.

(5)

ij

ij

Note that eq. (5) is a linear equality constraint on the ele-
ments of the output Gram matrix, just like eq. (3).

Because the geometric constraints on the outputs (cid:1)Yi are
so naturally expressed in terms of the Gram matrix Kij (and
because the outputs are determined up to rotation by their
Gram matrix), we may view manifold learning as an op-
timization over Gram matrices Kij rather than vectors (cid:1)Yi.
Not all matrices, however, can be interpreted as Gram ma-
trices: only symmetric matrices with nonnegative eigenval-
ues can be interpreted in this way. Thus, we must further
constrain the optimization to the cone of semidenite ma-
trices [21].

In sum, there are three types of constraints on the Gram
matrix Kij, arising from local isometry, centering, and
semideniteness. The rst two involve linear equality con-
straints; the last one is not linear, but importantly it is con-
vex. We will exploit this property in what follows. Note that
there are O(N k2) constraints on O(N 2) matrix elements,
and that the constraints are not incompatible, since at the
very least they are satised by the input Gram matrix Gij
(assuming, as before, that the inputs (cid:1)Xi are centered on the
origin).

Proceedings of the 2004 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR04)
1063-6919/04 $20.00  2004 IEEE

3.2. Optimization

What function of the Gram matrix can we optimize to
unfold a manifold, as in Fig. 1? As motivation, consider
the ends of a piece of string, or the corners of a ag. Any
slack in the string serves to decrease the (Euclidean) dis-
tance between its two ends; likewise, any furling of the ag
serves to bring its corners closer together. More generally,
we observe that any fold between two points on a mani-
fold serves to decrease the Euclidean distance between the
points. This suggests an optimization that we can perform
to compute the outputs (cid:1)Yi that unfold a manifold sampled
by inputs (cid:1)Xi. In particular, we propose to maximize the sum
of pairwise squared distances between outputs:

T (Y ) =

1
2N

(cid:5)

(cid:4)(cid:4)(cid:4)(cid:1)Yi  (cid:1)Yj

(cid:4)(cid:4)(cid:4)2

ij

.

(6)

By maximizing eq. (6), we pull the outputs as far apart as
possible, subject to the constraints in the previous section.
Before expressing this objective function in terms of the
Gram matrix Kij, let us verify that it is indeed bounded,
meaning that we cannot pull the outputs innitely far apart.
Intuitively, the constraints to preserve local distances (and
the assumption that the graph is connected) prevent such a
divergence. More formally, let ij =1 if (cid:1)Xj is one of the
k nearest neighbors of (cid:1)Xi, and zero otherwise, and let  be
the maximal distance between any two such neighbors:

(cid:6)
ij

(cid:4)(cid:4)(cid:4) (cid:1)Xi  (cid:1)Xj

(cid:4)(cid:4)(cid:4)

(cid:7)

 = max

ij

.

(7)

Assuming the graph is connected, then the longest path
through the graph has a distance of at most N  . We ob-
serve furthermore that given two nodes, the distance of the
path through the graph provides an upper bound on their Eu-
clidean distance. Thus, for all outputs (cid:1)Yi and (cid:1)Yj, we must
have |(cid:1)Yi  (cid:1)Yj| < N  . Using this to provide an upper bound
on the objective function in eq. (6), we obtain:
(N )2 = N 3 2

(cid:5)

.

T (Y )  1
2N

(8)

2

ij

Thus, the objective function cannot increase without bound
if we enforce the constraints to preserve local distances.

We can express the objective function in eq. (6) directly
in terms of the Gram matrix Kij of the outputs (cid:1)Yi. Expand-
ing the terms on the right hand side, and enforcing the con-
straint that the outputs are centered on the origin, we ob-
tain:

T (Y ) =

(cid:5)

(cid:4)(cid:4)(cid:4)(cid:1)Yi

(cid:4)(cid:4)(cid:4)2

=

(cid:5)

Kii = Tr(K).

(9)

i

i

Thus, we can interpret the objective function for the outputs
in several ways: as a sum over pairwise distances in eq. (6),

as a measure of variance in eq. (9), or as the trace of their
Gram matrix in eq. (9). The second interpretation is remi-
niscent of PCA, but whereas in PCA we compute the lin-
ear projection that maximizes variance, here we compute
the locally isometric embedding. Put another way, the ob-
jective function for maximizing variance remains the same;
we have merely changed the allowed form of the dimen-
sionality reduction. We also emphasize that in eq. (9), we
are maximizing the trace, not minimizing it. While a stan-
dard relaxation to minimizing the rank [9] of a semidenite
matrix is to minimize its trace, the intuition here is just the
opposite: we will obtain a low dimensional embedding by
maximizing the trace of the Gram matrix.

Let us now collect the costs and constraints of this opti-
mization. The problem is to maximize the variance of the
outputs {(cid:1)Yi}N
i=1 subject to the constraints that they are cen-
tered on the origin and locally isometric to the inputs
{ (cid:1)Xi}N
i=1. In terms of the input Gram matrix Gij = (cid:1)Xi  (cid:1)Xj,
the output Gram matrix Kij = (cid:1)Yi  (cid:1)Yj and the adja-
cency matrix ij indicating nearest neighbors, the opti-
mization can be written as:

(cid:1)

Maximize Tr(K) subject to K (cid:3) 0,

ij Kij = 0,

and ij such that ij =1 or [T ]ij =1,

Kii+KjjKijKji = Gii+GjjGijGji.

This problem is an instance of semidenite programming
(SDP) [21]: the domain is the cone of semidenite matrices
intersected with hyperplanes (represented by equality con-
straints), and the objective function is linear in the matrix
elements. The optimization is bounded above by eq. (8); it
is also convex, thus eliminating the possibility of spurious
local maxima. There exists a large literature on efciently
solving SDPs, as well as a number of general-purpose tool-
boxes. The results in this paper were obtained using the Se-
DuMi and CSDP 4.7 toolboxes [4, 18] in MATLAB.

3.3. Spectral Embedding

From the Gram matrix learned by semidenite program-
ming, we can recover the outputs (cid:1)Yi by matrix diagonaliza-
tion. Let Vi denote the ith element of the th eigenvec-
tor, with eigenvalue . Then the Gram matrix can be writ-
ten as:

Kij =

ViVj.

(10)

N(cid:5)

=1

(cid:8)

An N-dimensional embedding that is locally isometric to
the inputs (cid:1)Xi is obtained by identifying the th element of
the output (cid:1)Yi as:

Yi =

Vi.

(11)

Proceedings of the 2004 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR04)
1063-6919/04 $20.00  2004 IEEE

The eigenvalues of K are guaranteed to be nonnegative.
Thus, from eq. (11), a large gap in the eigenvalue spec-
trum between the dth and (d + 1)th eigenvalues indicates
that the inputs lie on or near a manifold of dimensional-
ity d. In this case, a low dimensional embedding that is ap-
proximately locally isometric is given by truncating the el-
ements of (cid:1)Yi. This amounts to projecting the outputs into
the subspace of maximal variance, assuming the eigenval-
ues are sorted from largest to smallest. The quality of the
approximation is determined by the size of the truncated
eigenvalues; there is no approximation error for zero eigen-
values. The situation is analogous to PCA and MDS, but
here the eigenvalue spectrum reects the underlying dimen-
sionality of a manifold, as opposed to merely a subspace.

The three steps of the algorithm, which we call Semidef-
inite Embedding (SDE), are summarized in Table 1. In its
simplest formulation, the only free parameter of the algo-
rithm is the number of nearest neighbors in the rst step.

(I)

Nearest
Neighbors

Compute the k nearest neighbors of each
input. Form the graph that connects each
input to its neighbors and each neighbor to
other neighbors of the same input.

(II)

Semidenite
Programming

Compute the Gram matrix of the maxi-
mum variance embedding, centered on the
origin, that preserves the distances of all
edges in the neighborhood graph.

(III)

Spectral

Embedding

Extract a low dimensional embedding
from the dominant eigenvectors of the
Gram matrix learned by semidenite pro-
gramming.

Table 1. Steps of Semidenite Embedding.

by semidenite programming. The top three eigenvectors
are plotted, but the variance in the third dimension (shown
to scale) is negligible. The eigenvalue spectrum in Fig. 7 re-
veals two dominant eigenvaluesa major eigenvalue, rep-
resenting the unwrapped length of the Swiss roll, and a
minor eigenvalue, representing its width. (The unwrapped
Swiss roll is much longer than it is wide.) The other eigen-
values are nearly zero, indicating that SDE has discovered
the true underlying dimensionality (d=2) of these inputs.
Fig. 2 shows another easily visualized example. The left
plot shows N = 539 inputs sampled from a trefoil knot in
D = 3 dimensions; the right plot shows the d = 2 embed-
ding discovered by SDE using k =4 nearest neighbors. The
color coding reveals that local neighborhoods have been
preserved. In this case, the underlying manifold is a one-
dimensional curve, but due to the cycle, it can only be repre-
sented in Euclidean space by a circle. The eigenvalue spec-
trum in Fig. 7 reveals two dominant eigenvalues; the rest
are essentially zero, indicating the underlying (global) di-
mensionality (d=2) of the circle.

Figure 2. Left: N = 539 inputs sampled along
a trefoil knot in D =3 dimensions. Right: d=2
embedding computed by SDE using k = 4
nearest neighbors. The color coding shows
that local neighborhoods are preserved.

4. Results

We used several data sets of curves, surfaces, and images
to evaluate the algorithm in Table 1 for low dimensional em-
bedding of high dimensional inputs.

Fig. 1 shows N = 800 inputs sampled off a Swiss
roll [19]. The inputs to the algorithm had D =8 dimen-
sions, consisting of the three dimensions shown in the g-
ure, plus ve extra dimensions1 lled with low variance
Gaussian noise. The bottom plot of the gure shows the un-
folded Swiss roll extracted from the Gram matrix learned

1

For K = 6 nearest neighbors, the noise in extra dimensions helps to
prevent the manifold from locking up when it is unfolded subject to
the equality constraints in eqs. (13). Alternatively, the constraints in
the SDP can be slightly relaxed by introducing slack variables.

Fig. 3 shows the results of SDE applied to color im-
ages of a three dimensional solid object. The images were
created by viewing a teapot from different angles in the
plane. The images have 76  101 pixels, with three byte
color depth, giving rise to inputs of D =23028 dimensions.
Though very high dimensional, the images in this data set
are effectively parameterized by one degree of freedom
the angle of rotation. SDE was applied to N = 400 images
spanning 360 degrees of rotation, with k = 4 nearest neigh-
bors used to generate a connected graph. The two dimen-
sional embedding discovered by SDE represents the rotat-
ing object as a circlean intuitive result analogous to the
embedding discovered for the trefoil knot. The eigenvalue
spectrum of the Gram matrix learned by semidenite pro-
gramming is shown in Fig. 7; all but the rst two eigenval-
ues are practically zero, indicating the underlying (global)
dimensionality (d=2) of the circle.

Proceedings of the 2004 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR04)
1063-6919/04 $20.00  2004 IEEE

Figure 3. Two dimensional embedding of
N =400 images of a rotating teapot, obtained
by SDE using k = 4 nearest neighbors. For
this experiment, the teapot was rotated 360
degrees; the low dimensional embedding is
a full circle. A representative sample of im-
ages are superimposed on top of the embed-
ding.

Fig. 4 was generated from the same data set of images;
however, for this experiment, only N = 200 images were
used, sampled over 180 degrees of rotation. In this case, the
eigenvalue spectrum from SDE detects that the images lie
on a one dimensional curve (see Fig. 7), and the d = 1 em-
bedding in Fig. 4 orders the images by their angle of rota-
tion.

Fig. 5 shows the results of SDE on a data set of N =1000
images of faces. The images contain different views and
expressions of the same face. The images have 28  20
grayscale pixels, giving rise to inputs with D = 560 di-
mensions. The plot in Fig. 5 shows the rst two dimensions
of the embedding discovered by SDE, using k = 4 nearest
neighbors. Interestingly, the eigenvalue spectrum in Fig. 7
indicates that most of the variance of the spectral embed-
ding is contained in the rst three dimensions.

Fig. 6 shows the results of SDE applied to another data
set of images. In this experiment, the images were a subset
of N = 638 handwritten TWOS from the USPS data set of
handwritten digits [10]. The images have 1616 grayscale
pixels, giving rise to inputs with D = 256 dimensions. In-
tuitively, one would expect these images to lie on a low di-
mensional manifold parameterized by such features as size,
slant, and line thickness. Fig. 6 shows the rst two dimen-
sions of the embedding obtained from SDE, with k =4 near-
est neighbors. The eigenvalue spectrum in Fig. 7 indicates a
latent dimensionality signicantly larger than two, but still
much smaller than the actual number of pixels.

Figure 5. Top: two dimensional embedding of
N = 1000 images of faces, obtained by SDE
using k = 4 nearest neighbors. Representa-
tive faces are shown next to circled points.
Bottom: eigenvalues of SDE and PCA on this
data set, indicating their estimates of the un-
derlying dimensionality. The eigenvalues are
shown as a percentage of the trace of the out-
put Gram matrix for SDE and the trace of the
input Gram matrix for PCA. The eigenvalue
spectra show that most of the variance of
the nonlinear embedding is conned to many
fewer dimensions than the variance of the lin-
ear embedding.

5. Discussion

The last few years have witnessed a number of de-
velopments in manifold learning. Recently proposed al-
gorithms include Isomap [19], locally linear embedding
(LLE) [14, 15], hessian LLE (hLLE) [8], and Laplacian
eigenmaps [1]; there are also related algorithms for clus-
tering [17]. All these algorithms share the same basic struc-
ture as SDE, consisting of three steps: (i) computing neigh-
borhoods in the input space, (ii) constructing a square ma-
trix with as many rows as inputs, and (iii) spectral embed-
ding via the top or bottom eigenvectors of this matrix. SDE
is based on a rather different geometric intuition, however,
and as a result, it has different properties.

Comparing the algorithms, we nd that each one at-
tempts to estimate and preserve a different geometric signa-

Proceedings of the 2004 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR04)
1063-6919/04 $20.00  2004 IEEE

Figure 4. One dimensional embedding of N = 200 images of a rotating teapot, obtained by SDE us-
ing k =4 nearest neighbors. For this experiment, the teapot was only rotated 180 degrees. Represen-
tative images are shown ordered by their location in the embedding.

maps estimate the Hessian and Laplacian on the manifold,
respectively; SDE estimates local angles and distances. Of
these algorithms, only Isomap, hLLE, and SDE attempt to
learn isometric embeddings; they are therefore the easiest
to compare (since they seek the same solution, up to rota-
tion and scaling). The results on the data set in Fig. 8 reveal
some salient differences between these algorithms. While
SDE and hLLE reproduce the original inputs up to isome-
try, Isomap fails in this example because the sampled man-
ifold is not isometric to a convex subset of Euclidean space.
(This is a key assumption of Isomap, one that is not sat-
ised by many image manifolds [7].) Moreover, compar-
ing the eigenvalue spectra of the algorithms, only SDE de-
tects the correct underlying dimensionality of the inputs;
Isomap is foiled by non-convexity, while the eigenvalue
spectra of LLE and hLLE do not reveal this type of infor-
mation [8, 15].

Overall, the different algorithms for manifold learning
should be viewed as complementary; each has its own ad-
vantages and disadvantages. LLE, hLLE, and Laplacian
eigenmaps construct sparse matrices, and as a result, they
are easier to scale to large data sets. On the other hand,
their eigenvalue spectra do not reliably reveal the under-
lying dimensionality of sampled manifolds, as do Isomap
and SDE. There exist rigorous proofs of asymptotic con-
vergence for Isomap [7, 22] and hLLE [8], but not for the
other algorithms. On the other hand, SDE by its very nature
provides nite-size guarantees that its constraints will lead
to locally isometric embeddings. We are not aware of any
nite-size guarantees provided by the other algorithms, and
indeed, the Hessian estimation in hLLE relies on numeri-
cal differencing, which can be problematic for small sample
sizes. Finally, while the different algorithms have different
computational bottlenecks, the second step in SDE (involv-
ing semidenite programming) is more computationally de-
manding than the analogous steps in LLE and Isomap.

Our initial results for SDE appear promising. There are
many important directions for future work. The most obvi-
ous is the investigation of faster methods for solving the
semidenite program in SDE. This study used a generic
solver that did not exploit the special structure of the con-
straints. A data set with N = 1000 points (and k = 4)
required about 30 minutes of computation time on a ma-
chine with a 2Ghz Pentium 4 processor. Data sets with
up to N = 1500 points took several hours. A specialized

Figure 6. Results of SDE using k = 4 nearest
neighbors on N = 638 images of handwritten
TWOS. Representative images are shown next
to circled points.

Figure 7. Eigenvalue spectra from SDE on
the data sets in this paper. The eigenvalues
are shown as a percentage of the trace of
the Gram matrix learned by semidenite pro-
gramming. SDE identies the correct under-
lying dimensionality of the Swiss roll, tre-
foil knot, and teapot data sets. The images
of faces and handwritten digits give rise to
many fewer non-zero eigenvalues than the
actual number of pixels.

ture of the underlying manifold. Isomap estimates geodesic
distances between inputs; LLE estimates the coefcients
of local linear reconstructions; hLLE and Laplacian eigen-

Proceedings of the 2004 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR04)
1063-6919/04 $20.00  2004 IEEE

[5] M. Brand. Charting a manifold. In S. Becker, S. Thrun, and
K. Obermayer, editors, Advances in Neural Information Pro-
cessing Systems 15, Cambridge, MA, 2003. MIT Press.

[6] T. Cox and M. Cox. Multidimensional Scaling. Chapman &

Hall, London, 1994.

[7] D. L. Donoho and C. E. Grimes. When does Isomap re-
cover the natural parameterization of families of articulated
images? Technical Report 2002-27, Department of Statis-
tics, Stanford University, August 2002.

[8] D. L. Donoho and C. E. Grimes. Hessian eigenmaps: locally
linear embedding techniques for high-dimensional data. Pro-
ceedings of the National Academy of Arts and Sciences,
100:55915596, 2003.

[9] M. Fazel, H. Hindi, and S. P. Boyd. A rank minimization
heuristic with application to minimum order system approx-
imation.
In Proceedings of the American Control Confer-
ence, volume 6, pages 47344739, June 2001.

[10] J. J. Hull. A database for handwritten text recognition re-
search. IEEE Transaction on Pattern Analysis and Machine
Intelligence, 16(5):550554, May 1994.

[11] I. T. Jolliffe. Principal Component Analysis. Springer-

Verlag, New York, 1986.

[12] H. Lu, Y. Fainman, and R. Hecht-Nielsen. Image manifolds.
In N. M. Nasrabadi and A. K. Katsaggelos, editors, Applica-
tions of Articial Neural Networks in Image Processing III,
Proceedings of SPIE, volume 3307, pages 5263, Belling-
ham, WA, 1998. SPIE.

[13] R. Pless and I. Simon.

Embedding images in non-at
spaces. Technical Report WU-CS-01-43, Washington Uni-
versity, December 2001.

[14] S. T. Roweis and L. K. Saul. Nonlinear dimensionality reduc-
tion by locally linear embedding. Science, 290:23232326,
2000.

[15] L. K. Saul and S. T. Roweis. Think globally, t locally: un-
supervised learning of low dimensional manifolds. Journal
of Machine Learning Research, 4:119155, 2003.

[16] B. Scholkopf, A. J. Smola, and K.-R. Muller. Nonlinear com-
ponent analysis as a kernel eigenvalue problem. Neural Com-
putation, 10:12991319, 1998.

[17] J. Shi and J. Malik. Normalized cuts and image segmenta-
tion. IEEE Transactions on Pattern Analysis and Machine
Intelligence (PAMI), pages 888905, August 2000.

[18] J. F. Sturm. Using SeDuMi 1.02, a MATLAB toolbox for
optimization overy symmetric cones. Optimization Methods
and Software, 11-12:625653, 1999.

[19] J. B. Tenenbaum, V. de Silva, and J. C. Langford. A global
geometric framework for nonlinear dimensionality reduc-
tion. Science, 290:23192323, 2000.

[20] M. Turk and A. Pentland. Eigenfaces for recognition. Jour-

nal of Cognitive Neuroscience, 3(1):7186, 1991.

[21] L. Vandenberghe and S. P. Boyd. Semidenite programming.

SIAM Review, 38(1):4995, March 1996.

[22] H. Zha and Z. Zhang. Isometric embedding and continuum
Isomap. In Proceedings of the Twentieth International Con-
ference on Machine Learning (ICML 2003), pages 864871,
2003.

Figure 8. Top: embedding of a non-convex
two dimensional data set (N = 500) by differ-
ent algorithms for manifold learning. Isomap,
LLE, and hLLE were run with k = 10 nearest
neighbors; SDE, with k =5 nearest neighbors.
Only hLLE and SDE reproduce the original in-
puts up to isometry. Bottom: only SDE has an
eigenvalue spectrum that indicates the cor-
rect dimensionality (d=2).

solver should allow us to scale SDE up to larger data sets
and larger neighborhood sizes. Another direction is relax
the constraints in eqs. (13) by introducing slack variables.
While slack variables do not change the basic structure of
the semidenite program, they may improve the robustness
of the algorithm on small or noisy data sets. Other directions
for future work include the investigation of image mani-
folds with different topologies [13] (such as those isomet-
ric to low dimensional spheres or torii), the extrapolation
of results to out-of-sample inputs [2], and the relation of
SDE to kernel methods for nonlinear dimensionality reduc-
tion [16]. Finally, as has been done for Isomap [7, 19, 22]
and hLLE [8], it would be desirable to formulate SDE in the
continuum limit and to construct rigorous proofs of asymp-
totic convergence. Such theoretical results would likely pro-
vide additional insight into the behavior of the algorithm.

